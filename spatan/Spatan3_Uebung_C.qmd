---
date: 2024-05-07
lesson: SpatAn3
topic: G-Function
index: 3
execute:
  echo: false   # set to true to show sample solution
  output: false # set to true to show sample solution
code-fold: true
code-summary: "Sample Solution"
knitr:
  opts_chunk:
    collapse: true  
---

# SpatAn 3: Exercise C (Optional)

In this optional exercise, we want to calculate and compare the G-function for measuring points in air quality and red kite movements.

## Task 1

```{r}
#| code-fold: false
#| echo: true

library("sf")
library("dplyr")
library("ggplot2")

red_kites <- read_sf("datasets/rauman/rotmilan.gpkg")
switzerland  <- read_sf("datasets/rauman/schweiz.gpkg")
air_quality <- read_sf("datasets/rauman/luftqualitaet.gpkg")
```

```{r}
#| output: true
#| label: fig-ggplot-ex1
#| fig.cap: Such a visualisation shows you, for example, the spatial extent of the data points
#| code-fold: false

ggplot(red_kites) +
  geom_sf(data = switzerland) +
  geom_sf(aes(colour = timestamp), alpha = 0.2) +
  scale_color_datetime(low = "blue", high = "red")
```

## Task 2

First, we will calculate the G function for the red kite positions:

### Step 1

With `st_distance()`, distances between two `sf` measurements can be calculated. If only one data record is specified, a cross matrix is created in which the distances between all features to all other features are displayed. We use this function to calculate the nearest neighbours.

```{r}
red_kites_distancematrix <- st_distance(red_kites)

nrow(red_kites_distancematrix)
ncol(red_kites_distancematrix)
# show the first 6 rows and columns of the matrix
# Each value is present twice (compare value [2,1] with [1,2])
# the diagonal is the distance to itself (equal to 0)
red_kites_distancematrix[1:6, 1:6]
```

### Step 2

Now we want to know how far the *shortest* distance from each point to its nearest neighbour is, i.e. the *shortest distance per line*. Before we determine these, we still have to remove the diagonal values, because these each represent the distance to themselves and are always `0`. Then `apply()` can be used to calculate a function (`FUN = min`) over the lines (`MARGIN = 1`) of a matrix (`X = red_kites_distancematrix`). In addition, we still have to set `na.rm = TRUE` so that `NA` values are excluded from the calculation. The result should be a vector with the same number of values as rows in the matrix.

```{r}
diag(red_kites_distancematrix) <- NA # delete all diagonal values

red_kites_distancematrix[1:6, 1:6]

red_kites_mindist <- apply(red_kites_distancematrix, 1, min, na.rm = TRUE)
```

### Step 3

Now we have to sort the distances according to their size

```{r}
red_kites_mindist <- sort(red_kites_mindist)
```

### Step 4

Now we will calculate the cumulative frequency of each distance. The cumulative frequency of the first value is 1 (the index of the first value) divided by the total number of values. `seq_along` provides us with the indices of all values. `length` provides us the total number of values.

```{r}
cumulative_frequency <- seq_along(red_kites_mindist) / length(red_kites_mindist)
```

### Step 5

Now we want to present the cumulative frequency of the values in an [Empirical Cumulative Distribution Function (ECDF)](https://en.wikipedia.org/wiki/Empirical_distribution_function). To do this, we first have to put the two vectors into a data frame so that `ggplot` can deal with them.

```{r}
#| output: true

red_kites_mindist_df <- data.frame(
  distances = red_kites_mindist,
  cumulative_frequency = cumulative_frequency
)

p <- ggplot() +
  geom_line(data = red_kites_mindist_df, aes(distances, cumulative_frequency)) +
  labs(x = "Distance (Meter)", y = "Frequency (cumulated)")
p
```

Reading

```{r}
#| output: true

prob <- 0.95
res <- quantile(ecdf(red_kites_mindist_df$distances), prob)
res2 <- quantile(ecdf(red_kites_mindist_df$distances), 0.99)
xlim <- c(5000, NA)
ylim <- c(.5, .75)
p +
  geom_segment(aes(x = res, xend = res, y = -Inf, yend = prob), colour = "lightblue") +
  geom_segment(aes(x = -Inf, xend = res, y = prob, yend = prob), colour = "lightblue") +
  geom_point(aes(x = res, y = prob), size = 3, colour = "lightblue") +
  ggrepel::geom_label_repel(aes(x = 0, y = prob, label = paste0(prob * 100, "% der Werte...")),
    xlim = xlim, ylim = ylim, hjust = 0, min.segment.length = 0, fill = "lightblue"
  ) +
  ggrepel::geom_label_repel(aes(x = res, y = 0, label = paste0("... is smaller than ", round(res, 0), "m")),
    xlim = xlim, ylim = ylim, hjust = 0, vjust = 1, fill = "lightblue", min.segment.length = 0, inherit.aes = FALSE
  ) +
  scale_y_continuous(breaks = c(0, .25, .5, .75, prob, 1))
```

## Task 3

Now perform the same steps with `air_quality` and compare the ECDF plots.

```{r}
#| output: true

air_quality_distancematrix <- st_distance(air_quality)

diag(air_quality_distancematrix) <- NA

air_quality_mindist <- apply(air_quality_distancematrix, 1, min, na.rm = TRUE)

air_quality_mindist <- sort(air_quality_mindist)

cumulative_frequency_air_quality <- seq_along(air_quality_mindist) / length(air_quality_mindist)

air_quality_mindist_df <- data.frame(
  distances = air_quality_mindist,
  cumulative_frequency = cumulative_frequency_air_quality
)

air_quality_mindist_df$data <- "air quality"
red_kites_mindist_df$data <- "red kite"

mindist_df <- rbind(air_quality_mindist_df, red_kites_mindist_df)

ggplot(mindist_df, ) +
  geom_line(aes(distances, cumulative_frequency, colour = data)) +
  labs(x = "Distance (Meter)", y = "Frequency (cumulated)", colour = "Data set")
```
