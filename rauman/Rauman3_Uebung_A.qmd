---
date: 2023-12-04
lesson: SpatAn3
topic: Density values
index: 1
execute:
  echo: false   # set to true to show sample solution
  output: false # set to true to show sample solution
code-fold: true
code-summary: "Sample Solution"
knitr:
  opts_chunk:
    collapse: true  
---

# SpatAn 3: Exercise A

For today's exercise, we need the following datasets. Import these into R. Check whether the CRS has been set correctly, set it if necessary. Familiarise yourself with the data (visualise, scroll through, etc.).

- *rotmilan.gpkg*: This dataset comes from a larger research project of the [Sempach Bird Observatory](https://www.vogelwarte.ch/de/projekte/oekologische-forschung/mechanismen-der-populationsdynamik-beim-rotmilan), which was made available via the movebank platform (see @scherler2020). It is based on the movements of a single bird which has been equipped with a transmitter since 2017 and travels all over Central Europe. In this exercise, we will only work with the data points recorded in Switzerland. If you want to analyse the entire data set, you can download it via the Movebank link.
- *luftqualitaet.gpkg*: This dataset includes measurements of nitrogen dioxide $NO_2$ from 2015 at 97 measurement points in Switzerland. Nitrogen dioxide is produced during the combustion of fuels, especially at high combustion temperatures, with road traffic as the main source.
   More information can be found [here](https://www.bafu.admin.ch/bafu/de/home/themen/thema-luft/luft--daten--indikatoren-und-karten/luft--indikatoren/indikator-luft.pt.html/aHR0cHM6Ly93d3cuaW5kaWthdG9yZW4uYWRtaW4uY2gvUHVibG/ljL0FlbURldGFpbD9pbmQ9TFUwMjAmbG5nPWRlJlN1Ymo9Tg%3d%3d.html).
- *schweiz.gpkg*: Swiss border

First of all, we want to carry out density estimates for the `air_quality` and `red_kites` data sets. Load the necessary packages into your R session beforehand.

```{r}
#| echo: true
#| code-fold: false

library("sf")
library("dplyr")
library("ggplot2")

library("spatstat.geom")
library("spatstat.explore")
```

```{r}
#| results: asis

air_quality <- read_sf("datasets/rauman/luftqualitaet.gpkg")
red_kites <- read_sf("datasets/rauman/rotmilan.gpkg")
switzerland <- read_sf("datasets/rauman/schweiz.gpkg")
```

## Task 1: Visualise red kite movement data

The first question typically asked in such movement studies is: *where can this bird usually be found?* To answer this question, the first thing to do is simply visualise the data points in a simple map. Create the map below to answer this question.

```{r}
#| output: true

ggplot(switzerland) +
  geom_sf() +
  geom_sf(data = red_kites) +
  theme_void()
```

## Task 2: Calculate Kernel Density Estimation

At first, this approach appears to work, but here we encounter the typical problem of "overplotting". This means that due to the overlay of many points in dense regions, we cannot estimate how many points are actually there and potentially overlapping. There are various ways to visualise the point density more clearly. A very popular method among biologists is density distribution with a Kernel Density Estimation (KDE). This is mainly because the habitat (home range) of an animal can be estimated using KDE. Home ranges are often defined with KDE95 and core areas are defined with KDE50 ([Fleming C., Calabrese J., 2016](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12673)).

To calculate the density, we use the `density.ppp` function from` spatstat`. This library is somewhat complex to use, but so that we can still apply this method to our red kite data, we have created our own KDE function.

We encourage those of you who can study our function in detail to not use it, and instead to use `spatstat` directly. If you want to work with our function, you'll need to copy and execute the code below into your script.

```{r}
#| echo: true
#| code-fold: false

my_kde <- function(points, cellsize, bandwith, extent = NULL){
  library("spatstat.geom")    # to convert to ppp
  library("spatstat.explore") # to calculate density

  points_ppp <- as.ppp(points) # convert sf > ppp

  if(!is.null(extent)){
    # if an extent has been given, this will be used
    # to set the observation window
    Window(points_ppp) <- as.owin(st_bbox(extent))
  }

  # Calculate density
  points_density <- density.ppp(x = points_ppp, sigma = bandwith, eps = cellsize)

  # Convert Output in a DataFrame
  points_density_df <- as.data.frame(points_density)

  points_density_df
}
```

The parameters of the function should be relatively clear:

- `points`: a point record from the class `sf`
- `cellsize`: the cell size of the output grid
- `bandwith`: The search radius for the density calculation
- `extent` (optional): the perimeter in which the density distribution is to be calculated. If no perimeter is specified, the "bounding box" of `points` should be used.

If we now use `my_kde()` to calculate density distribution, we get a `data.frame` with X and Y coordinates and a `value` column. Use these three columns with `geom_raster()` to visualise your `data` with `ggplot` `aes(x = X, y = Y, fill = value)`.
```{r}
#| echo: true
#| output: true
#| code-fold: false

red_kites_kde <- my_kde(points = red_kites, cellsize = 1000, bandwith = 10000, extent = switzerland)

head(red_kites_kde)
```

```{r}
#| output: true

ggplot() +
  geom_raster(data = red_kites_kde, aes(x, y, fill = value)) +
  geom_sf(data = switzerland, fill = NA) +
  scale_fill_viridis_c() +
  theme_void()
```

The kernel density estimation is now very much dominated by low values, as the density in most cells of our study area is close to zero. As mentioned, scientists are often only interested in the highest 95% of values. Follow these steps to depict results a little better:

1. Calculate the 95th percentile of all values with the function `quantile` and name this `q95`
2. Create a new column in `red_kites_kde` in which all values are lower than `q95` `NA`
3. (Optional): Transform the values with log10 to get a more differentiated gradient

We can hide the low values by representing only the highest 5% of the values. To accomplish this, we use `raster::quantile` to calculate the 95th percentile of all values and use this value as a "limit value" for the representation.

In addition, a logarithmic transformation of the values helps to make the colour scale somewhat more visible.

```{r}
#| output: true

q95 <- quantile(red_kites_kde$value, probs = 0.95)

red_kites_kde <- red_kites_kde |>
  mutate(
    value_new = ifelse(value > q95, value, NA),
    value_new = log10(value_new)
  )

ggplot() +
  geom_raster(data = red_kites_kde, aes(x, y, fill = value_new)) +
  geom_sf(data = switzerland, inherit.aes = FALSE, fill = NA) +
  scale_fill_viridis_c(na.value = NA) +
  theme_void()
```

## Task 3: Density distribution with Thiessen polygons

Thiessen polygons offer an exciting alternative for visualising differences in the density distribution of points in data sets.
We now want to try this out and construct Thiessen polygons for the red kite data in Switzerland. Use the instructions for creating Thiessen polygons from exercise B to create Thiessen polygons for the red kite positions.

```{r}
thiessenpolygone <- red_kites |>
  st_union() |>
  st_voronoi()
switzerland <- st_union(switzerland)

thiessenpolygone <- st_cast(thiessenpolygone)

thiessenpolygone_clip <- st_intersection(thiessenpolygone, switzerland)
```

```{r}
#| output: true
#| label: fig-ggplot-ex2-thiessen
#| fig.cap: 'It will be clearer if we depict Thiessen polygons without points,
#|   just how density within clusters appears'

ggplot() +
  geom_sf(data = switzerland) +
  geom_sf(data = thiessenpolygone_clip, fill = NA) +
  theme_void()
```
