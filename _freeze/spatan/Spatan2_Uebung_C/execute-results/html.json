{
  "hash": "07674f2773dbd3f2c41e103cb3b5622e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 2024-04-30\nlesson: SpatAn2\ntopic: Raster Data\nindex: 5\nexecute:\n  echo: true # set to true to show sample solution\n  output: true # set to true to show sample solution\ncode-fold: true\ncode-summary: \"Sample Solution\"\nknitr:\n  opts_chunk:\n    collapse: true  \n---\n\n\n# SpatAn 2: Exercise C1\n\nWe need the following datasets. Import these into R. Check whether the CRS has been set correctly, set it if necessary. Familiarise yourself with the data (visualise, scroll through, etc.).\n\n- *rotmilan.gpkg*: This dataset comes from a larger research project of the [Sempach Bird Observatory](https://www.vogelwarte.ch/de/projekte/oekologische-forschung/mechanismen-der-populationsdynamik-beim-rotmilan), which was made available via the movebank platform (see @scherler2020). It is based on the movements of a single bird which has been equipped with a transmitter since 2017 and travels all over Central Europe. In this exercise, we will only work with the data points recorded in Switzerland. If you want to analyse the entire data set, you can download it via the Movebank link.\n- *luftqualitaet.gpkg*: This dataset includes measurements of nitrogen dioxide $NO_2$ from 2015 at 97 measurement points in Switzerland. Nitrogen dioxide is produced during the combustion of fuels, especially at high combustion temperatures, with road traffic as the main source.\n   More information can be found [here](https://www.bafu.admin.ch/bafu/de/home/themen/thema-luft/luft--daten--indikatoren-und-karten/luft--indikatoren/indikator-luft.pt.html/aHR0cHM6Ly93d3cuaW5kaWthdG9yZW4uYWRtaW4uY2gvUHVibG/ljL0FlbURldGFpbD9pbmQ9TFUwMjAmbG5nPWRlJlN1Ymo9Tg%3d%3d.html).\n- *schweiz.gpkg*: Swiss border\n\nFirst of all, we want to carry out density estimates for the `air_quality` and `red_kites` data sets. Load the necessary packages into your R session beforehand.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"sf\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\n\nlibrary(\"spatstat.geom\")\nlibrary(\"spatstat.explore\")\n```\n:::\n\n\n```{.r .cell-code}\nair_quality <- read_sf(\"datasets/rauman/luftqualitaet.gpkg\")\nred_kites <- read_sf(\"datasets/rauman/rotmilan.gpkg\")\nswitzerland <- read_sf(\"datasets/rauman/schweiz.gpkg\")\n```\n\n\n## Task 1: Visualise red kite movement data\n\nThe first question typically asked in such movement studies is: *where can this bird usually be found?* To answer this question, the first thing to do is simply visualise the data points in a simple map. Create the map below to answer this question.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(switzerland) +\n  geom_sf() +\n  geom_sf(data = red_kites) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](Spatan2_Uebung_C_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## Task 2: Calculate Kernel Density Estimation\n\nAt first, this approach appears to work, but here we encounter the typical problem of \"overplotting\". This means that due to the overlay of many points in dense regions, we cannot estimate how many points are actually there and potentially overlapping. There are various ways to visualise the point density more clearly. A very popular method among biologists is density distribution with a Kernel Density Estimation (KDE). This is mainly because the habitat (home range) of an animal can be estimated using KDE. Home ranges are often defined with KDE95 and core areas are defined with KDE50 ([Fleming C., Calabrese J., 2016](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12673)).\n\nTo calculate the density, we use the `density.ppp` function from` spatstat`. This library is somewhat complex to use, but so that we can still apply this method to our red kite data, we have created our own KDE function.\n\nWe encourage those of you who can study our function in detail to not use it, and instead to use `spatstat` directly. If you want to work with our function, you'll need to copy and execute the code below into your script.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmy_kde <- function(points, cellsize, bandwith, extent = NULL){\n  library(\"spatstat.geom\")    # to convert to ppp\n  library(\"spatstat.explore\") # to calculate density\n\n  points_ppp <- as.ppp(points) # convert sf > ppp\n\n  if(!is.null(extent)){\n    # if an extent has been given, this will be used\n    # to set the observation window\n    Window(points_ppp) <- as.owin(st_bbox(extent))\n  }\n\n  # Calculate density\n  points_density <- density.ppp(x = points_ppp, sigma = bandwith, eps = cellsize)\n\n  # Convert Output in a DataFrame\n  points_density_df <- as.data.frame(points_density)\n\n  points_density_df\n}\n```\n:::\n\n\nThe parameters of the function should be relatively clear:\n\n- `points`: a point record from the class `sf`\n- `cellsize`: the cell size of the output grid\n- `bandwith`: The search radius for the density calculation\n- `extent` (optional): the perimeter in which the density distribution is to be calculated. If no perimeter is specified, the \"bounding box\" of `points` should be used.\n\nIf we now use `my_kde()` to calculate density distribution, we get a `data.frame` with X and Y coordinates and a `value` column. Use these three columns with `geom_raster()` to visualise your `data` with `ggplot` `aes(x = X, y = Y, fill = value)`.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nred_kites_kde <- my_kde(points = red_kites, cellsize = 1000, bandwith = 10000, extent = switzerland)\n\nhead(red_kites_kde)\n##         x       y        value\n## 1 2485909 1075767 5.706506e-24\n## 2 2485909 1076766 8.289075e-23\n## 3 2485909 1077764 3.029525e-23\n## 4 2485909 1078763 6.521282e-23\n## 5 2485909 1079761 9.598037e-23\n## 6 2485909 1080760 1.182799e-22\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_raster(data = red_kites_kde, aes(x, y, fill = value)) +\n  geom_sf(data = switzerland, fill = NA) +\n  scale_fill_viridis_c() +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](Spatan2_Uebung_C_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nThe kernel density estimation is now very much dominated by low values, as the density in most cells of our study area is close to zero. As mentioned, scientists are often only interested in the highest 95% of values. Follow these steps to depict results a little better:\n\n1. Calculate the 95th percentile of all values with the function `quantile` and name this `q95`\n2. Create a new column in `red_kites_kde` in which all values are lower than `q95` `NA`\n3. (Optional): Transform the values with log10 to get a more differentiated gradient\n\nWe can hide the low values by representing only the highest 5% of the values. To accomplish this, we use `raster::quantile` to calculate the 95th percentile of all values and use this value as a \"limit value\" for the representation.\n\nIn addition, a logarithmic transformation of the values helps to make the colour scale somewhat more visible.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq95 <- quantile(red_kites_kde$value, probs = 0.95)\n\nred_kites_kde <- red_kites_kde |>\n  mutate(\n    value_new = ifelse(value > q95, value, NA),\n    value_new = log10(value_new)\n  )\n\nggplot() +\n  geom_raster(data = red_kites_kde, aes(x, y, fill = value_new)) +\n  geom_sf(data = switzerland, inherit.aes = FALSE, fill = NA) +\n  scale_fill_viridis_c(na.value = NA) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](Spatan2_Uebung_C_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n## Task 3: Density distribution with Thiessen polygons\n\nThiessen polygons offer an exciting alternative for visualising differences in the density distribution of points in data sets.\nWe now want to try this out and construct Thiessen polygons for the red kite data in Switzerland. Use the instructions for creating Thiessen polygons from exercise B to create Thiessen polygons for the red kite positions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthiessenpolygone <- red_kites |>\n  st_union() |>\n  st_voronoi()\nswitzerland <- st_union(switzerland)\n\nthiessenpolygone <- st_cast(thiessenpolygone)\n\nthiessenpolygone_clip <- st_intersection(thiessenpolygone, switzerland)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = switzerland) +\n  geom_sf(data = thiessenpolygone_clip, fill = NA) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![It will be clearer if we depict Thiessen polygons without points, just how density within clusters appears](Spatan2_Uebung_C_files/figure-html/fig-ggplot-ex2-thiessen-1.png){#fig-ggplot-ex2-thiessen width=672}\n:::\n:::\n\n\n# SpatAn 2: Exercise C2\n\n\n::: {.cell}\n\n:::\n\n\nThis exercise is about implementing two different interpolation methods in R. In the first interpolation method we will use *inverse distance weighted interpolation*. Later, we will use the *nearest neighbour* method. To do this, you will need the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"sf\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\nlibrary(\"gstat\")\n```\n:::\n\n\nYou will also need the following datasets:\n\n\n\n```{.r .cell-code  code-fold=\"false\"}\nair_quality <- read_sf(\"datasets/rauman/luftqualitaet.gpkg\")\nswitzerland <- read_sf(\"datasets/rauman/schweiz.gpkg\")\n```\n\n\nThe `gstat` library offers various options for interpolating data points, including the *inverse distance weighted* method. Unfortunately, the package is not yet as user-friendly as `sf`: however, the package is currently being revised and it should be just as easily accessible in the future. So that you do not have to deal with the peculiarities of this library, we have prepared a function that should make it easier for you to use the IDW interpolation.\n\nWe have taken away some of the complexity and have provided you with a ready-to-use tool. While we provide a simpler function for ease of use, we also encourage those who can to explore and understand this function in detail, or even better, use the `gstat` package instead. If you want to work with our function, you have to copy and execute the code below into your script.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmy_idw <- function(groundtruth, column, cellsize, nmax = Inf, maxdist = Inf, idp = 2, extent = NULL){\n  library(\"gstat\")\n  library(\"sf\")\n\n  if(is.null(extent)){\n    extent <- groundtruth\n  }\n\n  samples <- st_make_grid(extent, cellsize, what = \"centers\")\n  my_formula <- formula(paste(column,\"~1\"))\n  idw_sf <- gstat::idw(formula = my_formula, groundtruth, newdata = samples, nmin = 1, nmax = nmax, maxdist = maxdist, idp = idp)\n\n  idw_matrix <- cbind(as.data.frame(st_coordinates(idw_sf)), pred = st_drop_geometry(idw_sf)[,1])\n  idw_matrix\n}\n```\n:::\n\n\nNow you can interpolate the `air_quality` data set with `my_idw()`as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmy_idw(groundtruth = air_quality, column = \"value\", cellsize = 10000, extent = switzerland)\n```\n:::\n\n\nThe following parameters are available:\n\n- **Necessary parameters**:\n   - `groundtruth`: point data record with measured values (`sf`object)\n   - `column`: name of the column with the measured values (in quotation marks and closing characters)\n   - `cellsize`: cell size of the output raster\n- **Optional parameters**\n   - `nmax`: maximum number of points to be taken into account for the interpolation. Default: `Inf` (all values in the given search radius)\n   - `maxdist`: Search radius to be used for interpolation. Default `Inf` (all values up to `nmax`)\n   - `idp`: ***Inverse Distance* Power:** the power with which the denominator is to be increased. Default: `2`. Values are weighted in the reciprocal of the square: $\\frac{1}{dist^{idp}}$.\n   - `extent`: area for which the interpolation is to be carried out. If nothing is specified (default `ZERO`), the extension of groundtruth `is` used.\n- **Ouput**\n   - the output of the function is a `data.frame` with 3 columns:\n      - `X`, `Y` coordinates of the interpolated values\n      - `pred`: the Interpolated Value\n\nThe output is a raster-like data type (see *Spatial Data Science* 1 lecture). We can visualise this with `geom_raster()` with `ggplot`. To do this, you must specify the `X` and `Y` coordinates in `aes`, and colour the interpolated value with `fill`.\n\n### Task 1: Spatial interpolation with IDW\n\nCalculates the IDW for the air quality measurements with different parameters and visualise the results in each case. Experiment with `nmax` and `maxdist`. What do you find?\n\nTips:\n\n- You can find out what distances make sense with `maxdist` from the output of the G function (previous exercise)\n- At the beginning, choose a slightly conservative (large) `cellsize` and only reduce it if your computer can handle it well\n- Since the output from the interpolation is in the same coordinate reference system as `schweiz.gpkg`, these two data sets can be displayed in the same `ggplot`. For this, you have to set the *aesthetics* (`aes()`) for each layer individually, and not at the level of `ggplot()`.\n\n::: {.column-body}\n\n::: {.cell}\n\n```\n## [inverse distance weighted interpolation]\n## [inverse distance weighted interpolation]\n## [inverse distance weighted interpolation]\n## [inverse distance weighted interpolation]\n```\n\n::: {.cell-output-display}\n![Nitrogen Dioxide (NO2) in μg/m3, Interpolate over all of Switzerland using the Inverse Distance Weighted Method. The various plots depict changes in the Interpolation with increasing IDP values](Spatan2_Uebung_C_files/figure-html/fig-ggplot-ex1-1.png){#fig-ggplot-ex1 width=672}\n:::\n:::\n\n:::\n\n### Task 2: Interpolation with Nearest Neighbour\n\nAnother simple way to interpolate is the creation of a Voronoi diagram, also known as Thiessen polygons or Dirichlet decomposition. `sf` has a `st_voronoi()` function, which assumes a point data set and constructs Thiessen polygons around the points. All it takes is a small preprocessing step: `sf` wants a voronoi diagram for each feature, i.e. for each *line* in our data set. This makes little sense for us, because each line consists of only one point. Therefore, we must first convert `air_quality` with `st_union()` from a `POINT` to a `MULTIPOINT` object in which all points are summarised in one line.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Spatan2_Uebung_C_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n`st_voronoi()` has pulled the Thiessen polygons a little further than we want them. However, this is a nice illustration of the edge effects of Thiessen polygons, which can become very large towards the edge (where it has fewer and fewer points). We can clip the polygons to just Switzerland with `st_intersection()`. Here, too, two small pre-processing steps are required:\n\n1. As before, we have to merge the individual cantonal polygons. We achieve this with `st_union()`. We save the output as `switzerland`, which as a result returns a single polygon in the shape of the Swiss borders.\n2. For the Thiessen polygons, we do exactly the opposite: `st_voronoi()` provides a single feature with all polygons, which has not been clipped. With `st_cast()`, the `GEOMETRYCOLLECTION` is divided into single polygons.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Spatan2_Uebung_C_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nNow we just need to determine the respective value for each polygon. We achieve this again with `st_join()`. Here, too, a *small* preprocessing step is necessary: We convert the `sfc` object (only geometries) into an `sf` object (geometries with attribute table).\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Nitrogen Dioxide (NO2) in μg/m3, Interpolate all of Switzerland using the Nearest Neighbour method.](Spatan2_Uebung_C_files/figure-html/fig-ggplot-ex2-final-1.png){#fig-ggplot-ex2-final width=672}\n:::\n:::\n",
    "supporting": [
      "Spatan2_Uebung_C_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}