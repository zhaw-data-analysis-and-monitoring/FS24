{
  "hash": "e2ddbdadf4d67d985d9ca47aec99ca07",
  "result": {
    "markdown": "---\ndate: 2024-05-07\nlesson: SpatAn3\ntopic: G-Function\nindex: 3\nexecute:\n  echo: true # set to true to show sample solution\n  output: true # set to true to show sample solution\ncode-fold: true\ncode-summary: \"Sample Solution\"\nknitr:\n  opts_chunk:\n    collapse: true  \n---\n\n\n# SpatAn 3: Exercise C (Optional)\n\nIn this optional exercise, we want to calculate and compare the G-function for measuring points in air quality and red kite movements.\n\n## Task 1\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"sf\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\n\nred_kites <- read_sf(\"datasets/rauman/rotmilan.gpkg\")\nswitzerland  <- read_sf(\"datasets/rauman/schweiz.gpkg\")\nair_quality <- read_sf(\"datasets/rauman/luftqualitaet.gpkg\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nggplot(red_kites) +\n  geom_sf(data = switzerland) +\n  geom_sf(aes(colour = timestamp), alpha = 0.2) +\n  scale_color_datetime(low = \"blue\", high = \"red\")\n```\n\n::: {.cell-output-display}\n![Such a visualisation shows you, for example, the spatial extent of the data points](Spatan3_Uebung_C_files/figure-html/fig-ggplot-ex1-1.png){#fig-ggplot-ex1 width=672}\n:::\n:::\n\n\n## Task 2\n\nFirst, we will calculate the G function for the red kite positions:\n\n### Step 1\n\nWith `st_distance()`, distances between two `sf` measurements can be calculated. If only one data record is specified, a cross matrix is created in which the distances between all features to all other features are displayed. We use this function to calculate the nearest neighbours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nred_kites_distancematrix <- st_distance(red_kites)\n\nnrow(red_kites_distancematrix)\n## [1] 2305\nncol(red_kites_distancematrix)\n## [1] 2305\n# show the first 6 rows and columns of the matrix\n# Each value is present twice (compare value [2,1] with [1,2])\n# the diagonal is the distance to itself (equal to 0)\nred_kites_distancematrix[1:6, 1:6]\n## Units: [m]\n##          1         2         3        4        5        6\n## 1     0.00 14362.044 20272.492 35596.07 52519.10 64156.67\n## 2 14362.04     0.000  8149.486 29752.74 44809.10 53775.25\n## 3 20272.49  8149.486     0.000 22580.04 36848.93 45662.55\n## 4 35596.07 29752.737 22580.037     0.00 17223.26 31439.57\n## 5 52519.10 44809.096 36848.926 17223.26     0.00 16499.19\n## 6 64156.67 53775.250 45662.554 31439.57 16499.19     0.00\n```\n:::\n\n\n### Step 2\n\nNow we want to know how far the *shortest* distance from each point to its nearest neighbour is, i.e. the *shortest distance per line*. Before we determine these, we still have to remove the diagonal values, because these each represent the distance to themselves and are always `0`. Then `apply()` can be used to calculate a function (`FUN = min`) over the lines (`MARGIN = 1`) of a matrix (`X = red_kites_distancematrix`). In addition, we still have to set `na.rm = TRUE` so that `NA` values are excluded from the calculation. The result should be a vector with the same number of values as rows in the matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag(red_kites_distancematrix) <- NA # delete all diagonal values\n\nred_kites_distancematrix[1:6, 1:6]\n## Units: [m]\n##          1         2         3        4        5        6\n## 1       NA 14362.044 20272.492 35596.07 52519.10 64156.67\n## 2 14362.04        NA  8149.486 29752.74 44809.10 53775.25\n## 3 20272.49  8149.486        NA 22580.04 36848.93 45662.55\n## 4 35596.07 29752.737 22580.037       NA 17223.26 31439.57\n## 5 52519.10 44809.096 36848.926 17223.26       NA 16499.19\n## 6 64156.67 53775.250 45662.554 31439.57 16499.19       NA\n\nred_kites_mindist <- apply(red_kites_distancematrix, 1, min, na.rm = TRUE)\n```\n:::\n\n\n### Step 3\n\nNow we have to sort the distances according to their size\n\n\n::: {.cell}\n\n```{.r .cell-code}\nred_kites_mindist <- sort(red_kites_mindist)\n```\n:::\n\n\n### Step 4\n\nNow we will calculate the cumulative frequency of each distance. The cumulative frequency of the first value is 1 (the index of the first value) divided by the total number of values. `seq_along` provides us with the indices of all values. `length` provides us the total number of values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncumulative_frequency <- seq_along(red_kites_mindist) / length(red_kites_mindist)\n```\n:::\n\n\n### Step 5\n\nNow we want to present the cumulative frequency of the values in an [Empirical Cumulative Distribution Function (ECDF)](https://en.wikipedia.org/wiki/Empirical_distribution_function). To do this, we first have to put the two vectors into a data frame so that `ggplot` can deal with them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nred_kites_mindist_df <- data.frame(\n  distances = red_kites_mindist,\n  cumulative_frequency = cumulative_frequency\n)\n\np <- ggplot() +\n  geom_line(data = red_kites_mindist_df, aes(distances, cumulative_frequency)) +\n  labs(x = \"Distance (Meter)\", y = \"Frequency (cumulated)\")\np\n```\n\n::: {.cell-output-display}\n![](Spatan3_Uebung_C_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nReading\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprob <- 0.95\nres <- quantile(ecdf(red_kites_mindist_df$distances), prob)\nres2 <- quantile(ecdf(red_kites_mindist_df$distances), 0.99)\nxlim <- c(5000, NA)\nylim <- c(.5, .75)\np +\n  geom_segment(aes(x = res, xend = res, y = -Inf, yend = prob), colour = \"lightblue\") +\n  geom_segment(aes(x = -Inf, xend = res, y = prob, yend = prob), colour = \"lightblue\") +\n  geom_point(aes(x = res, y = prob), size = 3, colour = \"lightblue\") +\n  ggrepel::geom_label_repel(aes(x = 0, y = prob, label = paste0(prob * 100, \"% der Werte...\")),\n    xlim = xlim, ylim = ylim, hjust = 0, min.segment.length = 0, fill = \"lightblue\"\n  ) +\n  ggrepel::geom_label_repel(aes(x = res, y = 0, label = paste0(\"... is smaller than \", round(res, 0), \"m\")),\n    xlim = xlim, ylim = ylim, hjust = 0, vjust = 1, fill = \"lightblue\", min.segment.length = 0, inherit.aes = FALSE\n  ) +\n  scale_y_continuous(breaks = c(0, .25, .5, .75, prob, 1))\n```\n\n::: {.cell-output-display}\n![](Spatan3_Uebung_C_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Task 3\n\nNow perform the same steps with `air_quality` and compare the ECDF plots.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair_quality_distancematrix <- st_distance(air_quality)\n\ndiag(air_quality_distancematrix) <- NA\n\nair_quality_mindist <- apply(air_quality_distancematrix, 1, min, na.rm = TRUE)\n\nair_quality_mindist <- sort(air_quality_mindist)\n\ncumulative_frequency_air_quality <- seq_along(air_quality_mindist) / length(air_quality_mindist)\n\nair_quality_mindist_df <- data.frame(\n  distances = air_quality_mindist,\n  cumulative_frequency = cumulative_frequency_air_quality\n)\n\nair_quality_mindist_df$data <- \"air quality\"\nred_kites_mindist_df$data <- \"red kite\"\n\nmindist_df <- rbind(air_quality_mindist_df, red_kites_mindist_df)\n\nggplot(mindist_df, ) +\n  geom_line(aes(distances, cumulative_frequency, colour = data)) +\n  labs(x = \"Distance (Meter)\", y = \"Frequency (cumulated)\", colour = \"Data set\")\n```\n\n::: {.cell-output-display}\n![](Spatan3_Uebung_C_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Spatan3_Uebung_C_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}