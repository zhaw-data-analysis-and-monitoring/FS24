{
  "hash": "55e0cccca5c0aad33e3cf6977aa17d22",
  "result": {
    "markdown": "---\ndate: 2023-11-27\nlesson: RaumAn1\nthema: Einführung\nindex: 1\nexecute: \n  echo: false   # set to true to show musterlösung\n  output: false # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true  \n---\n\n\n# Rauman 1: Übung A\n\nEs gibt bereits eine Vielzahl von Packages um in R mit räumlichen Daten zu arbeiten, die ihrerseits wiederum auf weiteren Packages basieren (Stichwort *dependencies*). Für *Vektordaten* dominierte lange das Package [`sp`](https://cran.r-project.org/package=sp), welches nun durch [`sf`](https://r-spatial.github.io/sf/) abgelöst wurde. Wir werden wenn immer möglich mit `sf` arbeiten und nur in Ausnahmefällen auf andere Packages zurück greifen.\n\nFür die kommenden Übungen könnt ihr folgende Packages installieren bzw. laden:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"sf\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\n```\n:::\n\n\n## Aufgabe 1: Vektor Daten importieren\n\nImportiere die Datensätze *kantone.gpkg* und *gemeinden.gpkg* wie folgt. Es handelt sich um Geodatensätze im Format Geopackage (\"\\*.gpkg\"), eine alternatives Datenformat zum bekannteren Format \"Shapefiles\". \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nkantone <- read_sf(\"datasets/rauman/kantone.gpkg\")\ngemeinden <- read_sf(\"datasets/rauman/gemeinden.gpkg\")\n```\n:::\n\n\nSchau Dir die importierten Datensätze an. \n\n:::{.callout-note}\nAm meisten Informationen zu `sf` Objekten bekommst du, wenn du dir den Datensatz *in der Konsole* anschaust (in dem du den Variabel-Name in der Konsole eintippst). Mit dem RStudio Viewer werden `sf` Objekte nur sehr langsam geladen und die Metadaten werden nicht angezeigt.\n:::\n\n## Aufgabe 2: Daten visualisieren\n\nEine sehr einfache Möglichkeit, `sf`-Objekte zu visualiseren ist die base-R Funktion `plot()`. Führe die angegebenen R-Befehle aus und studiere die entstehenden Plots. Welche Unterschiede findest Du? Wie erklärst Du diese Unterschiede?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# ohne max.plot = 1 macht R einen Plot pro Spalte\nplot(gemeinden, max.plot = 1)\n```\n\n::: {.cell-output-display}\n![](Rauman1_Uebung_A_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n\n# Alternativ kann man auch eine spezifische Spalte plotten\nplot(kantone[\"KANTONSFLA\"])\n```\n\n::: {.cell-output-display}\n![](Rauman1_Uebung_A_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\n\n## Input: Koodinatensysteme\n\nIn der obigen Visualierung fällt folgendes auf:\n\n- die X/Y Achsen weisen zwei ganz unterschiedliche Zahlenbereiche auf (vergleiche die Achsenbeschriftungen)\n- der Umriss der Schweiz sieht in den beiden Datensätzen unterschiedlich aus (`kantone` ist gegenüber `gemeinden` gestaucht)\n\nDies hat natürlich damit zu tun, dass die beiden Datensätze in unterschiedlichen Koordinatensystemen erfasst wurden. Koordinatensysteme werden mit CRS (**C**oordinate **R**eference **S**ystem) abgekürzt. Mit `st_crs()` können die zugewiesenen Koordinatensysteme abgefragt werden.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nst_crs(kantone)\n## Coordinate Reference System:\n##   User input: Undefined Cartesian SRS \n##   wkt:\n## ENGCRS[\"Undefined Cartesian SRS\",\n##     EDATUM[\"Unknown engineering datum\"],\n##     CS[Cartesian,2],\n##         AXIS[\"(E)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"Meter\",1]],\n##         AXIS[\"(N)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"Meter\",1]]]\nst_crs(gemeinden)\n## Coordinate Reference System:\n##   User input: Undefined Cartesian SRS \n##   wkt:\n## ENGCRS[\"Undefined Cartesian SRS\",\n##     EDATUM[\"Unknown engineering datum\"],\n##     CS[Cartesian,2],\n##         AXIS[\"(E)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"Meter\",1]],\n##         AXIS[\"(N)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"Meter\",1]]]\n```\n:::\n\n\nLeider sind in unserem Fall keine Koordinatensysteme zugewiesen. Mit etwas Erfahrung kann man das Koordinatensystem aber erraten, so viele kommen nämlich gar nicht in Frage. Am häufigsten trifft man hierzulande eines der drei folgenden Koordinatensysteme an:\n\n- `CH1903 LV03`: das alte Koordinatensystem der Schweiz\n- `CH1903+ LV95`: das neue Koordinatensystem der Schweiz\n- `WGS84`: ein häufig genutztes, weltumspannendes geodätisches Koordinatensystem, sprich die Koordinaten werden in Länge und Breite angegeben (Lat/Lon).\n\nNun gilt es, anhand der Koordinaten die in der Spalte `geometry` ersichtlich sind, das korrekte Koordinatensystem festzustellen. Wenn man auf [map.geo.admin.ch](https://map.geo.admin.ch) mit der rechten Maustaste einen Ort anwählt, erfährt man die Koordinaten dieses Ortes in verschiedenen Koordinatenbezugssystemen. \n\n![](images/map.geo.admin.png)\n\n<!--\nWenn man sich auf [epsg.io/map](https://epsg.io/map#srs=4326&x=8.407288&y=46.773731&z=9&layer=streets) die Schweiz anschaut, kann man die Koordinaten in verschiedenen Koordinatensystem betrachten.\n\n**Bedienungshinweise**:\n\n::: {layout=\"[50,50], [100]]\"}\n![Koordinanten (des Fadenkreuzes) werden im ausgewählten Koordinatensystem dargestellt](images/koordinatenpaar.jpg)\n\n![Das Koordinatensystem, in welchem die Koordinaten dargestellt werden sollen, kann mit \"Change\" angepasst werden](images/koordinatensystem.jpg)\n\n![Für Enthusiasten: Schau Dir die Schweiz in verschiedenen Koordinatensystemen an, in dem Du auf \"Reproject Map\" klickst](images/reproject.jpg)\n:::\n-->\n\nWenn man diese Koordinaten mit den Koordinaten unserer Datensätze vergleicht, dann ist schnell klar, dass es sich beim Datensatz `kantone` um das Koordinatenbezugsystem (CRS) WGS84 handelt. Wir können diese Information nutzen um das CRS unserers Datensatzes mit `st_set_crs()` zu setzen.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Zuweisen mit st_set_crs()...\nkantone <- st_set_crs(kantone, \"WGS84\")\n```\n:::\n\n\nWenn wir die CRS Information nun abrufen, sehen wir das diese Zuweisung funktioniert hat.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# ... abfragen mit st_crs()\nst_crs(kantone)\n## Coordinate Reference System:\n##   User input: WGS84 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     DATUM[\"World Geodetic System 1984\",\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     ID[\"EPSG\",4326]]\n```\n:::\n\n\nEtwas komplizierter ist es, wenn wir das CRS vom Datensatz `gemeinden` setzen wollen. Im Vergleich mit map.geo.admin.ch sehen wir, dass es sich hier um das CRS `CH1903+ LV95` handeln muss. Wenn wir diesen Namen für unsere CRS Zuweisung verwenden möchten, funktioniert das nicht:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Zuweisen mit st_set_crs()...\ngemeinden <- st_set_crs(gemeinden, \"CH1903+ LV95\")\n\n# ... abfragen mit st_crs()\nst_crs(gemeinden)\n```\n:::\n\n\nDie ausgeschriebenen Namen dieser CRS sind fehleranfällig. Deshalb ist es besser, mit den jeweiligen EPSG Codes der Bezugssysteme zu arbeiten. Diese EPSG Codes kann man auf folgender Website erfahren: [epsg.io/map](https://epsg.io/map#srs=4326&x=8.407288&y=46.773731&z=9&layer=streets). Es lohnt sich aber, die EPSG Codes der für uns relevanten CRS zu notieren:\n\n- [CH1903 LV03](https://epsg.io/21781): `EPSG:21781`\n- [CH1903+ LV95](https://epsg.io/2056): `EPSG:2056`\n- [WGS84](https://epsg.io/4326): `EPSG:4326`\n\nDieser Code können wir nutzen, um das CRS des Datensatz `gemeinde` zu setzen: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Zuweisen mit st_set_crs()...\ngemeinden <- st_set_crs(gemeinden, 2056)\n\n# ... abfragen mit st_crs()\nst_crs(gemeinden)\n## Coordinate Reference System:\n##   User input: EPSG:2056 \n##   wkt:\n## PROJCRS[\"CH1903+ / LV95\",\n##     BASEGEOGCRS[\"CH1903+\",\n##         DATUM[\"CH1903+\",\n##             ELLIPSOID[\"Bessel 1841\",6377397.155,299.1528128,\n##                 LENGTHUNIT[\"metre\",1]]],\n##         PRIMEM[\"Greenwich\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         ID[\"EPSG\",4150]],\n##     CONVERSION[\"Swiss Oblique Mercator 1995\",\n##         METHOD[\"Hotine Oblique Mercator (variant B)\",\n##             ID[\"EPSG\",9815]],\n##         PARAMETER[\"Latitude of projection centre\",46.9524055555556,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8811]],\n##         PARAMETER[\"Longitude of projection centre\",7.43958333333333,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8812]],\n##         PARAMETER[\"Azimuth of initial line\",90,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8813]],\n##         PARAMETER[\"Angle from Rectified to Skew Grid\",90,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8814]],\n##         PARAMETER[\"Scale factor on initial line\",1,\n##             SCALEUNIT[\"unity\",1],\n##             ID[\"EPSG\",8815]],\n##         PARAMETER[\"Easting at projection centre\",2600000,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8816]],\n##         PARAMETER[\"Northing at projection centre\",1200000,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8817]]],\n##     CS[Cartesian,2],\n##         AXIS[\"(E)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"metre\",1]],\n##         AXIS[\"(N)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"metre\",1]],\n##     USAGE[\n##         SCOPE[\"Cadastre, engineering survey, topographic mapping (large and medium scale).\"],\n##         AREA[\"Liechtenstein; Switzerland.\"],\n##         BBOX[45.82,5.96,47.81,10.49]],\n##     ID[\"EPSG\",2056]]\n```\n:::\n\n\nJetzt wo das CRS der Datensätze bekannt ist, können wir `ggplot2` nutzen um usere Daten zu visualisieren. In InfoVis 1 & 2 haben wir intensiv mit `ggplot2` gearbeitet und dort die Layers `geom_point()` und `geom_line()` kennen gelernt. Zusätzlich beinhaltet `ggplot` die Möglichkeit, mit `geom_sf()` Vektordaten direkt und sehr einfach zu plotten. \n\n\n::: {.cell}\n\n:::\n\n\n## Aufgabe 3: Koordinatensyteme *transformieren*\n\nIn der vorherigen Übung haben wir das bestehende Koordinatensystem *zugewiesen*. Dabei haben wir die bestehenden Koordinaten (in der Spalte `geom`) *nicht* manipuliert. Ganz anders ist eine *Transformation* der Daten von einem Koordinatensystem in das andere. Bei einer Transformation werden die Koordinaten in das neue Koordinatensystem umgerechnet und somit manipuliert. Aus praktischen Gründen wollen <!-- Was sind diese Gründe? genauer erläutern? -->\nwir all unsere Daten ins neue Schweizer Koordinatensystem CH1903+ LV95 transfomieren. Transformiere den Datensatz `kantone` mit `st_transform()`in CH1903+ LV95, nutze dafür den korrekten EPSG-Code.\n\nVor der Transformation (betrachte die Attribute `Bounding box`, `Projected CRS` sowie die Werte in der Spalte `geom`):\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nkantone\n## Simple feature collection with 51 features and 6 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: 5.955902 ymin: 45.81796 xmax: 10.49217 ymax: 47.80845\n## Geodetic CRS:  WGS 84\n## # A tibble: 51 × 7\n##    NAME       KANTONSNUM SEE_FLAECH KANTONSFLA KT_TEIL EINWOHNERZ\n##  * <chr>           <int>      <dbl>      <dbl> <chr>        <int>\n##  1 Graubünden         18         NA     710530 0           197888\n##  2 Bern                2      11897     595952 1          1031126\n##  3 Valais             23       1060     522463 0           341463\n##  4 Vaud               22      39097     321201 1           793129\n##  5 Ticino             21       7147     281216 0           353709\n##  6 St. Gallen         17       7720     202820 1           504686\n##  7 Zürich              1       6811     172894 0          1504346\n##  8 Fribourg           10       7818     167142 1           315074\n##  9 Luzern              3       6438     149352 0           406506\n## 10 Aargau             19        870     140380 1           670988\n## # ℹ 41 more rows\n## # ℹ 1 more variable: geom <POLYGON [°]>\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nNach der Transformation (betrachte die Attribute `Bounding box`, `Projected CRS` sowie die Werte in der Spalte `geom`):\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nkantone\n## Simple feature collection with 51 features and 6 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934\n## Projected CRS: CH1903+ / LV95\n## # A tibble: 51 × 7\n##    NAME       KANTONSNUM SEE_FLAECH KANTONSFLA KT_TEIL EINWOHNERZ\n##  * <chr>           <int>      <dbl>      <dbl> <chr>        <int>\n##  1 Graubünden         18         NA     710530 0           197888\n##  2 Bern                2      11897     595952 1          1031126\n##  3 Valais             23       1060     522463 0           341463\n##  4 Vaud               22      39097     321201 1           793129\n##  5 Ticino             21       7147     281216 0           353709\n##  6 St. Gallen         17       7720     202820 1           504686\n##  7 Zürich              1       6811     172894 0          1504346\n##  8 Fribourg           10       7818     167142 1           315074\n##  9 Luzern              3       6438     149352 0           406506\n## 10 Aargau             19        870     140380 1           670988\n## # ℹ 41 more rows\n## # ℹ 1 more variable: geom <POLYGON [m]>\n```\n:::\n\n\n## Aufgabe 4: Tidyverse Funktionen\n\n`sf` Objekte sind im wesentlichen `data.frames` mit ein paar Metadaten und einer speziellen `geometry`-Spalte. Wir können ihnen die gleichen Operationen durchführen, wie mit `data.frames`. Beispielsweise können wir aus den Spalten `EINWOHNERZ` und `KANTONSFLA` die Einwohnerdichte berechnen:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nkantone <- kantone |>\n  mutate(\n    # hektaren in km2 konvertieren\n    flaeche_km2 = KANTONSFLA / 100,\n    # dichte pro km2 berechnen\n    bevoelkerungsdichte = EINWOHNERZ / flaeche_km2\n  )\n```\n:::\n\n\nBerechne nun die Einwohnerdichte auf der Ebene der Gemeinden.\n\n\n::: {.cell}\n\n:::\n\n\n## Aufgabe 5: Choroplethen Karte\n\nNun wollen wir die Gemeinden respektive die Kantone nach ihrer Bevölkerungsdichte einfärben. Dafür verwenden wir wie gewohnt die Methode `aes(fill = ...)` von `ggplot`. \n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Rauman1_Uebung_A_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nHier sind farblich kaum Unterschiede erkennbar, weil die extrem hohe Bevölkerungsdichte vom Halbkanton Basel-Stadt (>5'000 Einwohner pro km<sup>2</sup>!) die ganze Farbskala dominiert. Der [Statistischer Atlas der Schweiz](https://www.atlas.bfs.admin.ch/maps/13/de/15467_75_3501_70/24216.html) löst das Problem, indem es Klassen mit irregulären Schwellwerte verwendet und alle zahlen >2'000 gruppiert. Diese Vorgehensweise können wir mit `cut()` rekonstruieren.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Schwellwerte analog BFS \"Statistischer Atlas der Schweiz\"\nbreaks = c(0, 50, 100, 150, 200, 300, 500, 750, 1000, 2000, Inf)\n\n# Klassen auf der Basis dieser Schwellenwerte bilden\nkantone <- kantone |>\n    mutate(bevoelkerungsdichte_klassen = cut(bevoelkerungsdichte, breaks))\n\n# Farbpalette erstellen: Wir brauchen so viele Farben, wie wir \"breaks\" haben, minus 1\nncols <- length(breaks) - 1\n\n# Farbpalette erstellen (siehe RColorBrewer::display.brewer.all())\nred_yellow_green <- RColorBrewer::brewer.pal(ncols, \"RdYlGn\")\n\n# Farbpalette umdrehen (zu green-red-yellow)\ngreen_red_yellow <- rev(red_yellow_green)\n\np_kantone <- ggplot(kantone, aes(fill = bevoelkerungsdichte_klassen)) +\n  geom_sf(colour = NA) +\n  scale_fill_manual(values = green_red_yellow) +\n  theme_void() +\n  theme(legend.position = \"none\")\n```\n:::\n\n\nErstelle die gleichen Klassen für die Bevölkerungsdichte der Gemeinden und vergleiche die Plots.\n\n\n::: {.cell}\n\n:::\n\n::: {#fig-ggplot-ex4 .cell .column-page layout-ncol=\"2\"}\n::: {.cell-output-display}\n![Kantone](Rauman1_Uebung_A_files/figure-html/fig-ggplot-ex4-1.png){#fig-ggplot-ex4-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Gemeinde](Rauman1_Uebung_A_files/figure-html/fig-ggplot-ex4-2.png){#fig-ggplot-ex4-2 width=672}\n:::\n\nDer Vergleich dieser beiden Darstellungen veranschaulicht die MAUP Problematik sehr deutlich\n:::\n",
    "supporting": [
      "Rauman1_Uebung_A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}