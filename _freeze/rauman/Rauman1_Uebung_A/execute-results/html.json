{
  "hash": "b50b47844722270cc85ec20240da3602",
  "result": {
    "markdown": "---\ndate: 2023-11-27\nlesson: SpatAn1\nTopic: Implementation\nindex: 1\nexecute:\n  echo: false   # set to true to show sample solution \n  output: false # set to true to show sample solution\ncode-fold: true\ncode-summary: \"Sample Solution\"\nknitr:\n  opts_chunk:\n    collapse: true  \n---\n\n\n# StatAn 1: Exercise A\n\nThere are already a large number of packages for working with spatial data in R, which in turn are based on other packages (keyword *dependencies*). For *vector data*, the  [`sp`](https://cran.r-project.org/package=sp) package dominated for a long time, and has now been replaced by [`sf`](https://r-spatial.github.io/sf/). Wherever possible, we will work with `sf` and only use other packages in exceptional cases.\n\nFor the upcoming exercises, you can install or load the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"sf\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\n```\n:::\n\n\n## Task 1: Import vector data\n\nImport the *kantone.gpkg* and *gemeinden.gpkg* records as follows. These are geodata sets in the geopackage (\"\\* .gpkg\") format, which is an alternative data format to the more well-known \"Shapefiles\" format.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ncantons <- read_sf(\"datasets/rauman/kantone.gpkg\")\nmunicipalities <- read_sf(\"datasets/rauman/gemeinden.gpkg\")\n```\n:::\n\n\nLook at the imported records.\n\n:::{.callout-note}\nYou will get the most information about `sf` objects if you look at the record *in the console* (by typing the variable name in the console). When using the RStudio Viewer, `sf` objects load very slowly and metadata is not displayed.\n:::\n\n## Task 2: Visualise data\n\nA very simple way of visualising `sf` objects is to use the `plot()` function in base-R. Execute the specified R commands and study the resulting plots. What differences can you see? How do you explain these differences?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# without max.plot = 1 will result in R per plot per column\nplot(municipalities, max.plot = 1)\n```\n\n::: {.cell-output-display}\n![](Rauman1_Uebung_A_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n\n# Alternatively, you can also plot a specific column\nplot(cantons[\"KANTONSFLA\"])\n```\n\n::: {.cell-output-display}\n![](Rauman1_Uebung_A_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\n\n## Input: Coordinate systems\n\nIn the above visualisation, the following is noticeable:\n\n- the X/Y axes have two very different number ranges (see the axis labels)\n- the outline of Switzerland looks different in the two datasets (`cantons` are compressed against `municipalities`)\n\nOf course, this has to do with the fact that the two data sets were recorded in different coordinate systems. Coordinate systems are abbreviated to CRS (**C**oordinate **R**eference **S**ystem). The assigned coordinate systems can be queried with `st_crs()`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nst_crs(cantons)\n## Coordinate Reference System:\n##   User input: Undefined Cartesian SRS \n##   wkt:\n## ENGCRS[\"Undefined Cartesian SRS\",\n##     EDATUM[\"\"],\n##     CS[Cartesian,2],\n##         AXIS[\"(E)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"Meter\",1]],\n##         AXIS[\"(N)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"Meter\",1]]]\nst_crs(municipalities)\n## Coordinate Reference System:\n##   User input: Undefined Cartesian SRS \n##   wkt:\n## ENGCRS[\"Undefined Cartesian SRS\",\n##     EDATUM[\"\"],\n##     CS[Cartesian,2],\n##         AXIS[\"(E)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"Meter\",1]],\n##         AXIS[\"(N)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"Meter\",1]]]\n```\n:::\n\n\nUnfortunately, no coordinate systems are assigned in our case. With a little experience, however, you can guess which coordinate system is used, because a lot of them can be ruled out. The three most common coordinate systems in Switzerland are as follows:\n\n- `CH1903 LV03`: the old coordinate system of Switzerland\n- `CH1903+ LV95`: the new coordinate system of Switzerland\n- `WGS84`: a frequently used, global geodetic coordinate system, i.e., the coordinates are given in length and width (lat/lon).\n\nIt is important to determine the correct coordinate system on the basis of the coordinates shown in the `geometry` column. If you select a location by right clicking on [map.geo.admin.ch](https://map.geo.admin.ch), you can find the coordinates of this location in various coordinate reference systems.\n\n![](images/map.geo.admin.png)\n\n<!--\nIf you look at Switzerland in [epsg.io/map](https://epsg.io/map#srs=4326&x=8.407288&y=46.773731&z=9&layer=streets), you can see coordinates in various systems.\n\n**How to Use**:\n\n::: {layout=\"[50,50], [100]]\"}\n![Coordinates in the crosshairs will be shown in the chosen coordinate system](images/koordinatenpaar.jpg)\n\n![You can change the coordinate system by selecting \"change\"](images/koordinatensystem.jpg)\n\n![For enthusiasts: Look at Switzerland in various coordinate systems by clicking \"Reproject Map\"](images/reproject.jpg)\n:::\n-->\n\nIf you compare these coordinates with the coordinates of our data sets, it quickly becomes clear that the `cantons` dataset is the coordinate reference system (CRS) WGS84. We can use this information to set the CRS of our dataset with `st_set_crs()`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Assign with st_set_crs()...\ncantons <- st_set_crs(cantons, \"WGS84\")\n```\n:::\n\n\nIf we now retrieve the CRS information, we should see that this task has been successfully completed.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# ... query with st_crs()\nst_crs(cantons)\n## Coordinate Reference System:\n##   User input: WGS84 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     DATUM[\"World Geodetic System 1984\",\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     ID[\"EPSG\",4326]]\n```\n:::\n\n\nIt is a bit more complicated if we want to set the CRS of the `municipalities` dataset. In comparison with map.geo.admin.ch, we can see that this must be the CRS `CH1903+ LV95`. Using this name for our CRS assignment won't work:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Assign with st_set_crs()...\nmunicipalities <- st_set_crs(municipalities, \"CH1903+ LV95\")\n\n# ... query with st_crs()\nst_crs(municipalities)\n```\n:::\n\n\nThe advertised names of these CRSs are prone to errors. Therefore, it is better to work with the respective EPSG codes of the reference systems. These EPSG codes can be found on the following website[:](https://epsg.io/map#srs=4326&x=8.407288&y=46.773731&z=9&layer=streets) epsg.io/map. It is worth noting the EPSG codes of the relevant CRS:\n\n- [CH1903 LV03](https://epsg.io/21781): `EPSG:21781`\n- [CH1903+ LV95](https://epsg.io/2056): `EPSG:2056`\n- [WGS84](https://epsg.io/4326): `EPSG:4326`\n\nWe can use this code to set the CRS of the `municipalities` dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Assign with st_set_crs()...\nmunicipalities <- st_set_crs(municipalities, 2056)\n\n# ... query with st_crs()\nst_crs(municipalities)\n## Coordinate Reference System:\n##   User input: EPSG:2056 \n##   wkt:\n## PROJCRS[\"CH1903+ / LV95\",\n##     BASEGEOGCRS[\"CH1903+\",\n##         DATUM[\"CH1903+\",\n##             ELLIPSOID[\"Bessel 1841\",6377397.155,299.1528128,\n##                 LENGTHUNIT[\"metre\",1]]],\n##         PRIMEM[\"Greenwich\",0,\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         ID[\"EPSG\",4150]],\n##     CONVERSION[\"Swiss Oblique Mercator 1995\",\n##         METHOD[\"Hotine Oblique Mercator (variant B)\",\n##             ID[\"EPSG\",9815]],\n##         PARAMETER[\"Latitude of projection centre\",46.9524055555556,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8811]],\n##         PARAMETER[\"Longitude of projection centre\",7.43958333333333,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8812]],\n##         PARAMETER[\"Azimuth of initial line\",90,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8813]],\n##         PARAMETER[\"Angle from Rectified to Skew Grid\",90,\n##             ANGLEUNIT[\"degree\",0.0174532925199433],\n##             ID[\"EPSG\",8814]],\n##         PARAMETER[\"Scale factor on initial line\",1,\n##             SCALEUNIT[\"unity\",1],\n##             ID[\"EPSG\",8815]],\n##         PARAMETER[\"Easting at projection centre\",2600000,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8816]],\n##         PARAMETER[\"Northing at projection centre\",1200000,\n##             LENGTHUNIT[\"metre\",1],\n##             ID[\"EPSG\",8817]]],\n##     CS[Cartesian,2],\n##         AXIS[\"(E)\",east,\n##             ORDER[1],\n##             LENGTHUNIT[\"metre\",1]],\n##         AXIS[\"(N)\",north,\n##             ORDER[2],\n##             LENGTHUNIT[\"metre\",1]],\n##     USAGE[\n##         SCOPE[\"Cadastre, engineering survey, topographic mapping (large and medium scale).\"],\n##         AREA[\"Liechtenstein; Switzerland.\"],\n##         BBOX[45.82,5.96,47.81,10.49]],\n##     ID[\"EPSG\",2056]]\n```\n:::\n\n\nNow that the CRS of the datasets is known, we can use `ggplot2` to visualise our data. In InfoVis 1 & 2, we worked intensively with `ggplot2` and got to know the `geom_point()` and `geom_line()` layers. `ggplot()` is also able to very easily plot vector data  with `geom_sf()`.\n\n\n::: {.cell}\n\n:::\n\n\n## Task 3: *Transform coordinate systems*\n\nIn the previous exercise, we *assigned* a coordinate system but we did *not* manipulate the existing coordinates (in the `geom` column). It is quite different to *transfer* the data from one coordinate system to the other. In the process of transforming the system, the coordinates are converted and thus manipulated. For practical reasons, <!-- What are the reasons? Can you explain in more detail? -->\nwe will transfer all our data into the new Swiss coordinate system CH1903+ LV95. Transform the `cantons` record with `st_transform()` into CH1903+ LV95, using the correct EPSG code.\n\nBefore transforming the data (consider the attributes `Bounding box`, `Projected CRS` as well as the values in the `geomcolumn`):\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ncantons\n## Simple feature collection with 51 features and 6 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: 5.955902 ymin: 45.81796 xmax: 10.49217 ymax: 47.80845\n## Geodetic CRS:  WGS 84\n## # A tibble: 51 × 7\n##    NAME       KANTONSNUM SEE_FLAECH KANTONSFLA KT_TEIL EINWOHNERZ\n##  * <chr>           <int>      <dbl>      <dbl> <chr>        <int>\n##  1 Graubünden         18         NA     710530 0           197888\n##  2 Bern                2      11897     595952 1          1031126\n##  3 Valais             23       1060     522463 0           341463\n##  4 Vaud               22      39097     321201 1           793129\n##  5 Ticino             21       7147     281216 0           353709\n##  6 St. Gallen         17       7720     202820 1           504686\n##  7 Zürich              1       6811     172894 0          1504346\n##  8 Fribourg           10       7818     167142 1           315074\n##  9 Luzern              3       6438     149352 0           406506\n## 10 Aargau             19        870     140380 1           670988\n## # ℹ 41 more rows\n## # ℹ 1 more variable: geom <POLYGON [°]>\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nAfter transferring the data (consider the `Bounding box` and `Projected CRS` attributes as well as the values in the `geom` column):\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ncantons\n## Simple feature collection with 51 features and 6 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934\n## Projected CRS: CH1903+ / LV95\n## # A tibble: 51 × 7\n##    NAME       KANTONSNUM SEE_FLAECH KANTONSFLA KT_TEIL EINWOHNERZ\n##  * <chr>           <int>      <dbl>      <dbl> <chr>        <int>\n##  1 Graubünden         18         NA     710530 0           197888\n##  2 Bern                2      11897     595952 1          1031126\n##  3 Valais             23       1060     522463 0           341463\n##  4 Vaud               22      39097     321201 1           793129\n##  5 Ticino             21       7147     281216 0           353709\n##  6 St. Gallen         17       7720     202820 1           504686\n##  7 Zürich              1       6811     172894 0          1504346\n##  8 Fribourg           10       7818     167142 1           315074\n##  9 Luzern              3       6438     149352 0           406506\n## 10 Aargau             19        870     140380 1           670988\n## # ℹ 41 more rows\n## # ℹ 1 more variable: geom <POLYGON [m]>\n```\n:::\n\n\n## Task 4: Tidyverse functions\n\n`sf` objects are essentially `data.frames` with a few metadata and a special `geometry` column. We can perform the same operations as with `data.frames`. For example, we can calculate the population density from the columns `EINWOHNERZ` and `KANTONSFLA`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ncantons <- cantons |>\n  mutate(\n    # convert hectares to km2\n    area_km2 = KANTONSFLA / 100,\n    # calculate population density per km2\n    population_density = EINWOHNERZ / area_km2\n  )\n```\n:::\n\n\nNow calculate the population density at the level of the municipalities.\n\n\n::: {.cell}\n\n:::\n\n\n## Task 5: Chloropleth Maps\n\nNow we want to colour the municipalities or the cantons according to their population density. As usual, we use the `aes(fill = ...)` method from `ggplot()`.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Rauman1_Uebung_A_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nThere are hardly any differences in colour, because the extremely high population density of Basel-Stadt (>5,000 inhabitants per km<sup>2</sup>!) dominates the entire colour scale. [Switzerland's Statistical Atlas](https://www.atlas.bfs.admin.ch/maps/13/de/15467_75_3501_70/24216.html) solves the problem by using classes with irregular thresholds and grouping all numbers >2,000. We can reproduce this procedure with `cut()`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Threshold is the same as BFS \"Statistical Atlas of Switzerland\"\nbreaks = c(0, 50, 100, 150, 200, 300, 500, 750, 1000, 2000, Inf)\n\n# show classes based on thresholds\ncantons <- cantons |>\n    mutate(population_density_classes = cut(population_density, breaks))\n\n# Create a colour palette: The number of colours needed is the number of \"breaks\" minus 1\nncols <- length(breaks) - 1\n\n# Create a colour palette (see RColorBrewer::display.brewer.all())\nred_yellow_green <- RColorBrewer::brewer.pal(ncols, \"RdYlGn\")\n\n# Invert colour palette (to green-red-yellow)\ngreen_red_yellow <- rev(red_yellow_green)\n\np_cantons <- ggplot(cantons, aes(fill = population_density_classes)) +\n  geom_sf(colour = NA) +\n  scale_fill_manual(values = green_red_yellow) +\n  theme_void() +\n  theme(legend.position = \"none\")\n```\n:::\n\n\nCreate the same classes for the population density of the communities and compare the plots.\n\n\n::: {.cell}\n\n:::\n\n::: {#fig-ggplot-ex4 .cell .column-page layout-ncol=\"2\"}\n::: {.cell-output-display}\n![Cantons](Rauman1_Uebung_A_files/figure-html/fig-ggplot-ex4-1.png){#fig-ggplot-ex4-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Municipalities](Rauman1_Uebung_A_files/figure-html/fig-ggplot-ex4-2.png){#fig-ggplot-ex4-2 width=672}\n:::\n\nComparing these depictions clearly shows the problems of MAUP\n:::\n",
    "supporting": [
      "Rauman1_Uebung_A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}