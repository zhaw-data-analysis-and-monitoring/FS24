{
  "hash": "5f45b1bdc8e9ccdfcac46a5b35237abd",
  "result": {
    "markdown": "---\ndate: 2023-12-04\nlesson: SpatAn3\ntopic: G-Function\nindex: 3\nexecute:\n  echo: false   # set to true to show sample solution\n  output: false # set to true to show sample solution\ncode-fold: true\ncode-summary: \"Sample Solution\"\nknitr:\n  opts_chunk:\n    collapse: true  \n---\n\n\n# SpatAn 3: Exercise C (Optional)\n\nIn this optional exercise, we want to calculate and compare the G-function for measuring points in air quality and red kite movements.\n\n## Task 1\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"sf\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\n\nred_kites <- read_sf(\"datasets/rauman/rotmilan.gpkg\")\nswitzerland  <- read_sf(\"datasets/rauman/schweiz.gpkg\")\nair_quality <- read_sf(\"datasets/rauman/luftqualitaet.gpkg\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Such a visualisation shows you, for example, the spatial extent of the data points](Rauman3_Uebung_C_files/figure-html/fig-ggplot-ex1-1.png){#fig-ggplot-ex1 width=672}\n:::\n:::\n\n\n## Task 2\n\nFirst, we will calculate the G function for the red kite positions:\n\n### Step 1\n\nWith `st_distance()`, distances between two `sf` measurements can be calculated. If only one data record is specified, a cross matrix is created in which the distances between all features to all other features are displayed. We use this function to calculate the nearest neighbours.\n\n\n::: {.cell}\n\n:::\n\n\n### Step 2\n\nNow we want to know how far the *shortest* distance from each point to its nearest neighbour is, i.e. the *shortest distance per line*. Before we determine these, we still have to remove the diagonal values, because these each represent the distance to themselves and are always `0`. Then `apply()` can be used to calculate a function (`FUN = min`) over the lines (`MARGIN = 1`) of a matrix (`X = red_kites_distancematrix`). In addition, we still have to set `na.rm = TRUE` so that `NA` values are excluded from the calculation. The result should be a vector with the same number of values as rows in the matrix.\n\n\n::: {.cell}\n\n:::\n\n\n### Step 3\n\nNow we have to sort the distances according to their size\n\n\n::: {.cell}\n\n:::\n\n\n### Step 4\n\nNow we will calculate the cumulative frequency of each distance. The cumulative frequency of the first value is 1 (the index of the first value) divided by the total number of values. `seq_along` provides us with the indices of all values. `length` provides us the total number of values.\n\n\n::: {.cell}\n\n:::\n\n\n### Step 5\n\nNow we want to present the cumulative frequency of the values in an [Empirical Cumulative Distribution Function (ECDF)](https://en.wikipedia.org/wiki/Empirical_distribution_function). To do this, we first have to put the two vectors into a data frame so that `ggplot` can deal with them.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Rauman3_Uebung_C_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nReading\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Rauman3_Uebung_C_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Task 3\n\nNow perform the same steps with `air_quality` and compare the ECDF plots.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Rauman3_Uebung_C_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Rauman3_Uebung_C_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}