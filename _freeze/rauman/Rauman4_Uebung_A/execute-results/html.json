{
  "hash": "b808151c8cebe6bc3ce939180737d731",
  "result": {
    "markdown": "---\ndate: 2023-12-05\nlesson: RaumAn4\nthema: Morans I\nindex: 1\nexecute: \n  echo: false   # set to true to show musterlösung\n  output: false # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true  \n---\n\n\n# Rauman 4: Übung\n\nHeute berechnen wir Morans $I$, also ein globales Mass für Autokorrelation, für die Abstimmungsresultate der Zweitwohnungsinitiative. Dieser Wert beschreibt, ob Kantone, die nahe beieinander liegen, ähnliche Abstimmungswerte haben. Hierfür verwenden wir den Datensatz *zweitwohnungsinitiative.gpkg*.\n\nDas Geopackage beinhaltet 3 Layers (siehe `st_layers(zweitwohnung_kanton)`). In jedem Layer sind die Abstimmungsresultate auf eine andere politische Ebene aggregiert. Wir started mit der Aggregationsstufe \"kanton\".\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\nlibrary(\"sf\")\n\nzweitwohnung_kanton <- read_sf(\"datasets/rauman/zweitwohnungsinitiative.gpkg\", layer = \"kanton\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\np <- ggplot(zweitwohnung_kanton) +\n  geom_sf(aes(fill = ja_in_percent), colour = \"white\", lwd = 0.2) +\n  scale_fill_gradientn(\"Ja-Anteil\",\n    colours = RColorBrewer::brewer.pal(11, \"RdYlGn\"),\n    limits = c(0, 100),\n  ) +\n  labs(title = \"Zweitwohnungsinititiative (2012)\", subtitle = \"Anteil Ja-Stimmen\") +\n  theme(legend.position = \"bottom\")\np\n```\n\n::: {.cell-output-display}\n![Was für einen Autokorrelationswert würdest du erwarten? Eher 1 (hohe Autokorrelation, beieinanderliegende Kantone haben ähnliche Werte) oder eher -1 (beieinanderliegende Kantone haben sehr unterschiedliche Werte) oder eher 0 (gar keine Autokorrelation)](Rauman4_Uebung_A_files/figure-html/fig-autokorrelation-kantone-1.png){#fig-autokorrelation-kantone width=672}\n:::\n:::\n\n\nFür die Berechnung von Morans $I$ benutzen wir kein externes Package, sondern erarbeiten uns alles selber, basierend auf der Formel von Moran's $I$: \n\n$$\n\\begin{aligned}\n\\text{Morans } I &= \\frac{\\color{cyan}n}{\\color{cyan}\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\color{red}\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\color{cyan}\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}} \\\\\n\\\\\n&= \\frac{\\color{cyan}\\text{zaehler1}}{\\color{cyan}\\text{nenner1}}\\times\\frac{\\color{red}\\text{zaehler2}}{\\color{cyan}\\text{nenner2}}\n\\end{aligned}\n$$ {#eq-morans-i}\n\n<span style=\"color:#FF0000\">Rot</span> markiert entpricht der Summe der gewichtetn Ähnlichkeitsmatrix aus der Vorlesung. Alles <span style=\"color:#00FFFF\">blaue</span> ist relativ trivial und dient lediglich der Normalisierung auf die Werte -1 bis +1. Die Begriffe `zaehler1`, `nenner1` usw. sind die Variablen, die wir in R für die jeweiligen Berechnungen nutzen werden und dienen lediglich der Orientierung. Zudem gilt: \n\n- $n$: Anzahl räumlichen Objekte (hier: 26 Kantone)\n- $y$: die untersuchte Variabel (hier: Ja-Anteil in %)\n- $\\bar{y}$: Mittelwert der untersuchten Variabel\n- $w_{ij}$: die Gewichtsmatrix\n\n## Aufgabe 1: Morans $I$ für Kantone\n\n### Gewichtete Ähnlichkeitsmatrix\n\nWidmen wir uns dem Kern von Morans $I$, der Berechnung der gewichteten Ähnlichkeitsmatrix.\n\n#### Nachbarschaftsmatrix $w_{ij}$\n\n$$\\text{Morans } I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n {\\color{red}w_{ij}}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n$w$ beschreibt die räumlichen Gewichte der Kantone (den \"Schalter\" aus der Vorlesung). $w_{ij}$ ist das Gewicht vom Kanton $i$ im Vergleich zum Kanton $j$. Sind Kantone $i$ und $j$ räumlich nah, gilt ein Gewicht von 1, sind sie weit entfernt, gilt ein Gewicht von 0. Dabei ist die Definition von \"räumlich nah\" nicht festgelegt. Denkbar wären verschiedene Optionen (siehe Vorlesung). Wer werden es mit die Bedigungen *touches* verwenden. Die Funktion `st_touches` prüft zwischen allen Kantonen, ob sie sich berühren. Mit der Option `sparse = TRUE` wird eine 26x26 Kreuzmatrix erstellt, wo jeder Kanton mit jedem anderen verglichen wird. Berühren sie sich, steht in der entsprechenden Stelle der Wert `TRUE`, was in R gleichbedeutend ist wie 1. Berühren sie sich *nicht*, steht der Wert `FALSE`, was gleichbedeutend ist wie 0. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# st_touches berechnet eine Kreuzmatrix aller Objekte\nw_ij <- st_touches(zweitwohnung_kanton, sparse = FALSE)\n\n# Schauen wir uns matrix mal an\n# (aus Platzmangen beschränken wir uns auf die ersten 5 Zeilen und Spalten\n# in RStudio könnt ihr mit View(w_ij) die gesamte Matrix anschauen)\nw_ij[1:5, 1:5]\n```\n:::\n\n\n<!-- Seltsamerweise gehen bei der Konvertierung die Matrix-Eigenschaft verloren (spricht: die Aufteilung der 26x26 Werte in Zeilen und Spalten). Diese müssen wir manuell wieder Herstellen. -->\n\nDie erste Zeile entspricht dem ersten Kanton in `zweitwohnung_kanton`, die zweite Zeile dem zweiten Kanton usw. Das gleiche Gilt für die Spalten. Um die Kreuzmatrix besser interpretieren zu können, können wir die Namen aus der Spalte `KANTONSNAME` verwenden, um die Zeilen und Spalten unserer Kreuzmatrix zu benennen.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nrownames(w_ij) <- zweitwohnung_kanton$kuerzel\ncolnames(w_ij) <- zweitwohnung_kanton$kuerzel\n\nw_ij[1:5, 1:5]\n# Alterantiv: mit View(w_ij)\n```\n:::\n\n\n#### Attributs-Ähnlichkeitsmatrix $c_{ij}$ {#sec-attributs-aehnlichkeitsmatrix}\n\n$$\\text{Morans } I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}{\\color{red}(y_i - \\bar{y})(y_j - \\bar{y})}}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\nUm die Attributs-Ähnlichkeit zwischen zwei Kantonen zu bestimmen, subtrahieren wir von jedem Kanton den Mittelwert aller Kantone und multiplizieren die beiden Differenzen. Die Funktion `tcrossprod()` erstellt diese Kreuzmatrix mit den multiplizierten Differenzen.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# speichere die Variable in einem neuen Vektor\ny <- zweitwohnung_kanton$ja_in_percent\n\ny_diff <- y - mean(y) # erstellt ein Vector mit 26 Werten\nc_ij <- tcrossprod(y_diff) # erstellt eine Matrix 26x26\n\n# Zeilen- und Spaltennamen hinzufügen\nrownames(c_ij) <- zweitwohnung_kanton$kuerzel\ncolnames(c_ij) <- zweitwohnung_kanton$kuerzel\n\nc_ij[1:5, 1:5]\n```\n:::\n\n\n#### Berechnung von `zaehler2`\n\n$$\\text{Morans } I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\color{red}\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\nDer gesamte Term `zaehler2` ist die Summe aus der Multiplikation von `w_ij` und `c_ij`. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Matrix multiplikation\ncw_ij <- w_ij * c_ij\n\n# Summe bilden\nzaehler2 <- sum(cw_ij)\n\nzaehler2\n```\n:::\n\n\n### Normalisieren\n\nUm das Resultat aus der bisherigen Berechung auf einen Wert von -1 bis +1 zu normalisieren, müssen wir noch folgende Terme berechnen:\n\n$$\\text{Morans } I = \\frac{\\color{cyan}n}{\\color{cyan}\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\color{cyan}\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}} $$\n\n#### Berechnung von $n$ (`zaehler1`)\n\nDer Termin `zaehler1` resp. `n` entspricht der Anzahl Objekte (hier: Kantone) in unserem Datensatz. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nzaehler1 <- n <- nrow(zweitwohnung_kanton)\n\nzaehler1\n```\n:::\n\n\n#### Abweichung vom Mittelwert (`nenner1`)\n\nWir haben bereits in der Berechnung der [Attributs-Ähnlichkeit](#sec-attributs-aehnlichkeitsmatrix) die Differenz zum Mittelwert berechnet. Für `nenner1` müssen wir diesen lediglich quadrieren und die Resultate summieren.\n\n$$\\text{Morans } I = \\frac{n}{\\color{cyan}\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Di bereits berechneten Abweichungen müssen wir quadrieren:\ny_diff2 <- y_diff^2\n\n# Und danach die Summe bilden:\nnenner1 <- sum(y_diff2)\n```\n:::\n\n\n#### Summe der Gewichte (`nenner2`)\n\n$$\\text{Morans } I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\color{cyan}\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\nIm Term `nenner2` müssen wir lediglich die Gewichte `w_ij` summieren.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nnenner2 <- sum(w_ij)\n```\n:::\n\n\n### Auflösung der Formel\n\nNun haben wir alle Bestandteile von Morans $I$ Berechnet und müssen diese nur noch Zusammenrechnen.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nMI_kantone <- zaehler1 / nenner1 * zaehler2 / nenner2\n\nMI_kantone\n```\n:::\n\n\nDer Global Morans $I$ für die Abstimmungsdaten beträgt auf Kantonsebene also 0.31. Wie interpretiert ihr dieses Resultate? Was erwartet ihr für eine Resultat auf Bezirksebene?\n\n## Aufgabe 2: Morans I für Bezirke berechnen\n\nNun könnt ihr Morans $I$ auf der Ebene der Bezirke und untersuchen, ob und wie sich Morans $I$ verändert. Importiert dazu den Layer `bezirk` aus dem Datensatz `zweitwohnungsinitiative.gpkg`. Visualisiert in einem ersten Schritt die Abstimmungsresultate. Formuliert nun eine Erwartungshaltung: ist Morans $I$ auf der Ebene Bezirke tiefer oder Höher als auf der Ebene Kantone? \n\n:::{.callout-note}\n## Für Fortgeschrittene \n\nErstellt aus dem erarbeiten Workflow eine *function* um Morans I auf der Basis von einem `sf` Objekt sowie einer Spalte dessen zu berechnen. \n\n\n::: {.cell}\n\n:::\n\n:::\n\n\n::: {.cell}\n\n:::\n\n::: {.cell .column-page layout-ncol=\"2\"}\n::: {.cell-output-display}\n![](Rauman4_Uebung_A_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Rauman4_Uebung_A_files/figure-html/unnamed-chunk-13-2.png){width=672}\n:::\n:::\n\n::: {.cell .column-page}\n::: {.cell-output-display}\n![](Rauman4_Uebung_A_files/figure-html/unnamed-chunk-14-1.png){width=100%}\n:::\n:::\n",
    "supporting": [
      "Rauman4_Uebung_A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}