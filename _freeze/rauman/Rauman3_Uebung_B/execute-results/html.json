{
  "hash": "7e8aeae1b0e23d818d37507f423c55a8",
  "result": {
    "markdown": "---\ndate: 2023-12-04\nlesson: RaumAn3\nthema: Räumliche Interpolation\nindex: 2\nexecute: \n  echo: false   # set to true to show musterlösung\n  output: false # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true\n---\n\n\n# Rauman 3: Übung B\n\n\n::: {.cell}\n\n:::\n\n\nIn dieser Übung geht es darum, zwei verschiedene Interpolationsverfahren in R umzusetzen. Im ersten Interpolationsverfahren verwenden wir die *inverse distance weighted interpolation*, später verwenden wir die *nearest neighbour* methode. Dazu braucht ihr die folgenden Packages:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"sf\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\nlibrary(\"gstat\")\n```\n:::\n\n\nWeiter benötigt ihr die nachstehenden Datensätze:\n\n\n\n```{.r .cell-code  code-fold=\"false\"}\nluftqualitaet <- read_sf(\"datasets/rauman/luftqualitaet.gpkg\")\nschweiz <- read_sf(\"datasets/rauman/schweiz.gpkg\")\n```\n\n\nDie Library `gstat` bietet verschiedene Möglichkeiten, Datenpunkte zu interpolieren, unter anderem auch die *inverse distance weighted* Methode. Leider ist das Package noch nicht so benutzerfreundlich wie `sf`: Das Package wird aber aktuell überarbeitet und in mittlerer Zukunft sollte es ebenso einfach  zugänglich sein. Damit Ihr Euch nicht mit den Eigenheiten dieser Library umschlagen müsst, haben wir eine Function vorbereitet, die Euch die Verwendung der IDW-Interpolation erleichtern soll.\n\nWir nehmen Euch damit etwas Komplexität weg und liefern Euch ein pfannenfertiges Werkzeug. Das hat auch Nachteile und wir ermutigen alle, die dafür Kapazität haben, unsere Function eingehend zu studieren und allenfalls ganz auf die Function zu verzichten und stattdessen direkt `gstat` zu verwenden. Wenn ihr mit unserer Function arbeiten möchtet, müsst ihr den unten stehenden Code in euer Skript kopieren und ausführen. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmy_idw <- function(groundtruth,column,cellsize, nmax = Inf, maxdist = Inf, idp = 2, extent = NULL){\n  library(\"gstat\")\n  library(\"sf\")\n  \n  if(is.null(extent)){\n    extent <- groundtruth\n  }\n  \n  samples <- st_make_grid(extent,cellsize,what = \"centers\")\n  my_formula <- formula(paste(column,\"~1\"))\n  idw_sf <- gstat::idw(formula = my_formula,groundtruth, newdata = samples, nmin = 1, nmax = nmax, maxdist = maxdist, idp = idp)\n  \n  idw_matrix <- cbind(as.data.frame(st_coordinates(idw_sf)),pred = st_drop_geometry(idw_sf)[,1])\n  idw_matrix\n}\n```\n:::\n\n\nNun könnt Ihr mit `my_idw()` den Datensatz `luftqualitaet` folgendermassen interpolieren. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmy_idw(groundtruth = luftqualitaet, column = \"value\", cellsize = 10000, extent = schweiz)\n```\n:::\n\n\nFolgende Parameter stehen Euch zur Verfügung:\n\n- **Notwendige Parameter**:\n  - `groundtruth`: Punktdatensatz mit den Messwerten (`sf`-Objekt)\n  - `column`: Name der Spalte mit den Messwerten (in Anführungs- und Schlusszeichen)\n  - `cellsize`: Zellgrösse des output Rasters\n- **Optionale Parameter**\n  - `nmax`: Maximale Anzahl Punkte, die für die Interpolation berücksichtigt werden sollen. Default: `Inf` (alle Werte im gegebenen Suchradius)\n  - `maxdist`: Suchradius, welcher für die Interpolation verwendet werden soll. Default `Inf` (alle Werte bis `nmax`)\n  - `idp`: **I**nverse **D**istance **P**ower: die Potenz, mit der der Nenner gesteigert werden soll. Default: `2`. Werte werden im Kehrwert des Quadrates gewichtet: $\\frac{1}{dist^{idp}}$.\n  - `extent`: Gebiet, für welches die Interpolation durchgeführt werden soll. Wenn nichts angegeben wird (Default `NULL`), wird die Ausdehnung von `groundtruth` verwendet.\n- **Ouput**\n  - der Output der Funktion ist eine `data.frame` mit 3 Spalten: \n    - `X`, `Y` Koordinaten der interpolierten Werte\n    - `pred`: der Interpolierte Wert\n  \nBeim Output handelt sich hier um einen Raster-ähnlichen Datentyp (siehe Vorlesung *Spatial DataScience 1*). Diesen können wir mit `geom_raster` mit `ggplot` visualisieren. Dafür müsst ihr in `aes` die `X` und `Y` Koordinaten angeben, und der interpolierte Wert mit `fill` einfärben.\n\n### Aufgabe 1: Raeumliche Interpolation mit IDW\n\nRechnet so den IDW für die Luftqualitätsmessungen mit verschiedenen Parametern und visualisiert jeweils die Resultate. Experimentiert mit `nmax` sowie `maxdist`. Was stellt ihr fest? \n\nTips: \n\n- Was für Distanzen bei `maxdist` Sinn machen, könnt ihr dem Output aus der G-Funktion (vorherige Übung) entnehmen\n- Wählt am Anfang eine etwas Konvervative (grosse) `cellsize` und verringert diesen nur wenn euer Rechner damit gut klar kommt\n- Da der Output aus der Interpolation im gleichen Koordinatenbezugssystem sind wie `schweiz.gpkg` kann man diese beiden Datensätze im gleichen `ggplot` darstellen. Dafür müsst ihr die *aesthetics* (`aes()`) für jeden Layer einzeln setzen, und nicht auf der Ebene von `ggplot()`.\n\n::: {.column-body}\n\n::: {.cell}\n\n```\n## [inverse distance weighted interpolation]\n## [inverse distance weighted interpolation]\n## [inverse distance weighted interpolation]\n## [inverse distance weighted interpolation]\n```\n\n::: {.cell-output-display}\n![Stickstoffdioxid (NO2) in μg/m3, Interpoliert über die ganze Schweiz mit der Inverse Distance Weighted Methode. Die verschiedenen Plots zeigen die Veränderung der Interpolation bei steigendem IDP-Wert](Rauman3_Uebung_B_files/figure-html/fig-ggplot-ex1-1.png){#fig-ggplot-ex1 width=672}\n:::\n:::\n\n:::\n\n### Aufgabe 2: Interpolation mit Nearest Neighbour\n\nEine weitere einfache Möglichkeit zur Interpolation bietet die Erstellung eines Voronoi-Diagrammes, auch als Thiessen-Polygone oder Dirichlet-Zerlegung bekannt. `sf` liefert dazu die Funktion `st_voronoi()`, die einen Punktdatensatz annimmt und eben um die Punkte die Thiessenpolygone konstruiert. Dazu braucht es lediglich einen kleinen Vorverarbeitungsschritt: `sf` möchte für jedes Feature, also für jede *Zeile* in unserem Datensatz, ein Voronoidiagramm. Das macht bei uns wenig Sinn, weil jede Zeile nur aus einem Punkt besteht. Deshalb müssen wir vorher `luftqualitaet` mit `st_union()` von einem `POINT` in ein `MULTIPOINT` Objekt konvertieren, in welchem alle Punkte in einer Zeile zusammengefasst sind.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Rauman3_Uebung_B_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n`st_voronoi` hat die Thiessenpolygone etwas weiter gezogen als wir sie wollen. Dies ist allerdings eine schöne Illustration der Randeffekte von Thiessenpolygonen, die zum Rand hin (wo es immer weniger Punkte hat) sehr gross werden können. Wir können die Polygone auf die Ausdehnung der Schweiz mit `st_intersection()` clippen. Auch hier braucht es zwei kleine Vorverarbeitungsschritte:\n\n1. wie vorher müssen wir die einzelnen Kantons-Polygone miteinander verschmelzen. Dies erreichen wir mit `st_union()`. Wir speichern den Output als `schweiz`, was als Resultat ein einzelnes Polygon der Schweizergrenze retourniert.\n2. für die Thiessen-Polygone machen wir genau das Umgekehrte: `st_voronoi()` liefert ein einzelnes Feature mit allen Polygonen, welches sich nicht gerne clippen lässt. Mit `st_cast()` wird die `GEOMETRYCOLLECTION` in Einzelpolygone aufgeteilt. \n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Rauman3_Uebung_B_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nJetzt müssen wir nur noch den jeweiligen Wert für jedes Polygon ermitteln. Dies erreichen wir wieder durch `st_join`. Auch hier ist noch ein *kleiner* Vorverarbeitungsschritt nötig: Wir konvertieren das `sfc` Objekt (nur Geometrien) in ein `sf` Objekt (Geometrien mit Attributtabelle).\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Stickstoffdioxid (NO2) in μg/m3, Interpoliert über die ganze Schweiz nach der Nearest Neighbour Methode.](Rauman3_Uebung_B_files/figure-html/fig-ggplot-ex2-final-1.png){#fig-ggplot-ex2-final width=672}\n:::\n:::\n",
    "supporting": [
      "Rauman3_Uebung_B_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}