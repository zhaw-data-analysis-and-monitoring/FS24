{
  "hash": "c4e46afc34231fd9ff685ef3abfa5661",
  "result": {
    "markdown": "---\ndate: 2023-10-17\nlesson: PrePro3\nthema: Split-Apply-Combine\nindex: 2\nexecute: \n  echo: true   # set to true to show musterlösung\n  output: true # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true\n---\n\n\n# Prepro 3: Übung\n\n## Aufgabe 1\n\nGegeben sei ein Datensatz *sensors_combined.csv*, mit den Temperaturwerten von drei verschiedenen Sensoren. Importiere ihn als csv in R (als `sensors_combined`). \n\nFormatiere die `Datetime` Spalte in `POSIXct` um. Verwende dazu die Funktion `as.POSIXct` (lies mit `?strftime()` nochmal nach wie du das spezfische Format (die \"Schablone\") festlegen kannst.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"readr\")\n\nsensors_combined <- read_delim(\"datasets/prepro/sensors_combined.csv\", \",\")\n\nsensors_combined$Datetime <- as.POSIXct(sensors_combined$Datetime, format = \"%d%m%Y_%H%M\")\n```\n:::\n\n\n## Aufgabe 2\n\nÜberführe die Tabelle in ein *langes* Format (verwende dazu die Funktion `pivot_longer` aus `tidyr`) und speichere den output als `sensors_long`. \n\nTipp: \n\n- im Argument `cols` kannst du entweder die Spalten auflisten, die \"pivotiert\" werden sollen. \n- Alternativ kannst du (mit vorangestelltem Minuszeichen, `-`) die Spalte, bezeichnen, die *nicht* pivotiert werden soll. \n- In beiden Fällen musst du die Spalten weder mit Anführungs- und Schlusszeichen noch mit dem `$`-Zeichen versehen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tidyr\")\n\n# Variante 1 (Spalten abwählen)\nsensors_long <- pivot_longer(sensors_combined, -Datetime) \n\n# Variante 2 (Spalten anwählen)\nsensors_long <- pivot_longer(sensors_combined, c(sensor1:sensor3))\n```\n:::\n\n\n## Aufgabe 3\n\nGruppiere `sensors_long` nach der neuen Spalte wo die Sensor-Information enthalten ist (default: `name`) mit `group_by` und berechne die mittlere Temperatur pro Sensor (`summarise`). Hinweis: Beide Funktionen sind Teil des Packages `dplyr`.\n\nDer Output sieht folgendermassen aus: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"dplyr\")\n\nsensors_long |>\n  group_by(name) |>\n  summarise(temp_mean = mean(value, na.rm = TRUE))\n## # A tibble: 3 × 2\n##   name    temp_mean\n##   <chr>       <dbl>\n## 1 sensor1      14.7\n## 2 sensor2      12.0\n## 3 sensor3      14.4\n```\n:::\n\n\n## Aufgabe 4\n\nErstelle für `sensors_long` eine neue *convenience* Variabel `month` welche den Monat beinhaltet (Tipp: verwende dazu die Funktion `month` aus `lubridate`). Gruppiere nun nach `month` *und* Sensor und berechne die mittlere Temperatur. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"lubridate\")\n\nsensors_long |>\n  mutate(month = month(Datetime)) |>\n  group_by(month, name) |>\n  summarise(temp_mean = mean(value, na.rm = TRUE))\n## # A tibble: 6 × 3\n## # Groups:   month [2]\n##   month name    temp_mean\n##   <dbl> <chr>       <dbl>\n## 1    10 sensor1     14.7 \n## 2    10 sensor2     12.7 \n## 3    10 sensor3     14.4 \n## 4    11 sensor1    NaN   \n## 5    11 sensor2      8.87\n## 6    11 sensor3    NaN\n```\n:::\n\n\n## Aufgabe 5\n\nLade jetzt nochmal den Datensatz *weather.csv* (Quelle MeteoSchweiz) herunter und importiere ihn als CSV mit den korrekten Spaltentypen (`stn` als `factor`, `time` als `POSIXct`, `tre200h0` als `double`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather <- read_delim(\"datasets/prepro/weather.csv\", col_types = cols(col_factor(), col_datetime(\"%Y%m%d%H\"), col_double()), \",\")\n```\n:::\n\n\n## Aufgabe 6\n\nErstelle nun eine *convenience Variable* für die Kalenderwoche pro Messung (`lubridate::isoweek`). Berechne im Anschluss den mittleren Temperaturwert pro Kalenderwoche.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary <- weather |>\n  mutate(week = isoweek(time)) |>\n  group_by(week) |>\n  summarise(\n    temp_mean = mean(tre200h0, na.rm = TRUE)\n  )\n```\n:::\n\n\nVisualisiere im Anschluss das Resultat:\n\n\n\n```{.r .cell-code}\nplot(weather_summary$week, weather_summary$temp_mean, type = \"l\")\n```\n\n![](Prepro3_Uebung_files/figure-html/unnamed-chunk-7-1.png){width=672}\n\n\n## Aufgabe 7\n\nIn der vorherigen Aufgabe haben wir die mittlere Temperatur pro Kalenderwoche über *alle Jahre* (2000 und 2001) berechnet. Wenn wir die Jahre aber miteinander vergleichen wollen, müssen wir das Jahr als zusätzliche *convenience Variable* erstellen und danach gruppieren. Versuche dies mit den Wetterdaten und visualisiere den Output anschliessend.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary2 <- weather |>\n  mutate(\n    week = week(time),\n    year = year(time)\n    ) |>\n  group_by(year, week) |>\n  summarise(\n    temp_mean = mean(tre200h0, na.rm = TRUE)\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(weather_summary2$week, weather_summary2$temp_mean, type = \"l\")\n```\n\n::: {.cell-output-display}\n![baseplot mag keine long tables und macht aus den beiden Jahren eine kontinuierliche Linie](Prepro3_Uebung_files/figure-html/fig-baseplot-ex7-1.png){#fig-baseplot-ex7 width=672}\n:::\n:::\n\n\n## Aufgabe 8\n\nÜberführe den Output aus der letzten Übung in eine *wide table*. Nun lassen sich die beiden Jahre viel besser miteinander vergleichen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary2 <- weather_summary2 |>\n  pivot_wider(names_from = year, values_from = temp_mean,names_prefix = \"year\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(weather_summary2$week, weather_summary2$year2000, type = \"l\",col = \"blue\")\nlines(weather_summary2$week, weather_summary2$year2001, type = \"l\",col = \"red\")\n```\n\n::: {.cell-output-display}\n![](Prepro3_Uebung_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Prepro3_Uebung_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}