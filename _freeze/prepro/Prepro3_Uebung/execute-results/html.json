{
  "hash": "45ba41849bd5f6c962233c93f9112109",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 2024-03-05\nlesson: PrePro3\ntopic: Split-Apply-Combine\nindex: 2\nexecute:\n  echo: true # set to true to show sample solution\n  output: true # set to true to show sample solution\ncode-fold: true\ncode-summary: \"Sample Solution\"\nknitr:\n  opts_chunk:\n    collapse: true\n---\n\n\n# Prepro 3: Exercise\n\n## Task 1\n\nYou have a dataset, *sensors_combined.csv*, with temperature values from three different sensors. Import it as a csv into R (as `sensors_combined`).\n\nReformat the `datetime` column to `POSIXct`. Use the `as.POSIXct` function (read it in using`?strftime())` to determine the specific format (the template).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"readr\")\n\nsensors_combined <- read_delim(\"datasets/prepro/sensors_combined.csv\", \",\")\n\nsensors_combined$Datetime <- as.POSIXct(sensors_combined$Datetime, format = \"%d%m%Y_%H%M\")\n```\n:::\n\n\n## Task 2\n\nConvert the table to a *long* format (use the `pivot_longer` function from `tidyr`) and save the output as `sensors_long`.\n\nTips:\n\n- In the `cols` argument, you can list the columns that should be pivoted.\n- Alternatively, you can indicate (by placing a minus sign in front, `-`) the column that should *not* be pivoted.\n- In either case, you do not need to put the columns in quotation marks or end them with the `$`sign.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tidyr\")\n\n# Option 1 (Deselect columns)\nsensors_long <- pivot_longer(sensors_combined, -Datetime)\n\n# Option 2 (Select columns)\nsensors_long <- pivot_longer(sensors_combined, c(sensor1:sensor3))\n```\n:::\n\n\n## Task 3\n\nGroup `sensors_long` according to the new column where the sensor information is contained (default: `name`) with `group_by` and calculate the average temperature for each sensor (`summarise`). Note: Both functions are part of the `dplyr` package.\n\nThe output will look like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"dplyr\")\n\nsensors_long |>\n  group_by(name) |>\n  summarise(temp_mean = mean(value, na.rm = TRUE))\n## # A tibble: 3 × 2\n##   name    temp_mean\n##   <chr>       <dbl>\n## 1 sensor1      14.7\n## 2 sensor2      12.0\n## 3 sensor3      14.4\n```\n:::\n\n\n## Task 4\n\nCreate a new *convenience* variable, `month`, for `sensors_long` (Tip: use the `month` function from `lubridate`). Now group by `month` *and* sensor and calculate the mean temperature.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"lubridate\")\n\nsensors_long |>\n  mutate(month = month(Datetime)) |>\n  group_by(month, name) |>\n  summarise(temp_mean = mean(value, na.rm = TRUE))\n## # A tibble: 6 × 3\n## # Groups:   month [2]\n##   month name    temp_mean\n##   <dbl> <chr>       <dbl>\n## 1    10 sensor1     14.7 \n## 2    10 sensor2     12.7 \n## 3    10 sensor3     14.4 \n## 4    11 sensor1    NaN   \n## 5    11 sensor2      8.87\n## 6    11 sensor3    NaN\n```\n:::\n\n\n## Task 5\n\nNow download the *weather.csv* dataset (source MeteoSwiss) and import it as a .csv with the correct column types (`stn` as a `factor`, `time` as `POSIXct`, `tre200h0` as `double`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather <- read_delim(\"datasets/prepro/weather.csv\", col_types = cols(col_factor(), col_datetime(\"%Y%m%d%H\"), col_double()), \",\")\n```\n:::\n\n\n## Task 6\n\nNow create a *convenience variable* for the calendar week for each measurement (`lubridate::isoweek`). Then calculate the average temperature value for each calendar week.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary <- weather |>\n  mutate(week = isoweek(time)) |>\n  group_by(week) |>\n  summarise(\n    temp_mean = mean(tre200h0, na.rm = TRUE)\n  )\n```\n:::\n\n\nNext visualise the result:\n\n\n\n```{.r .cell-code}\nplot(weather_summary$week, weather_summary$temp_mean, type = \"l\")\n```\n\n![](Prepro3_Uebung_files/figure-html/unnamed-chunk-7-1.png){width=672}\n\n\n## Task 7\n\nIn the previous task, we calculated the average temperature per calendar week over *all years* (2000 and 2001). However, if we want to compare the years with each other, we have to create the year as an additional *convenience variable* and group it accordingly. Try this with the weather data and then visualise the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary2 <- weather |>\n  mutate(\n    week = week(time),\n    year = year(time)\n    ) |>\n  group_by(year, week) |>\n  summarise(\n    temp_mean = mean(tre200h0, na.rm = TRUE)\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(weather_summary2$week, weather_summary2$temp_mean, type = \"l\")\n```\n\n::: {.cell-output-display}\n![Base plot does not like long tables and makes a continuous line out of the two years](Prepro3_Uebung_files/figure-html/fig-baseplot-ex7-1.png){#fig-baseplot-ex7 width=672}\n:::\n:::\n\n\n## Task 8\n\nTransfer the output from the last exercise to a *wide table*. Now the two years can be compared much more easily.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary2 <- weather_summary2 |>\n  pivot_wider(names_from = year, values_from = temp_mean,names_prefix = \"year\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(weather_summary2$week, weather_summary2$year2000, type = \"l\",col = \"blue\")\nlines(weather_summary2$week, weather_summary2$year2001, type = \"l\",col = \"red\")\n```\n\n::: {.cell-output-display}\n![](Prepro3_Uebung_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Prepro3_Uebung_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}