{
  "hash": "7fd192108fd852df5220820c250dfdd8",
  "result": {
    "markdown": "---\ndate: 2023-10-17\nlesson: PrePro3\ntopic: Split-Apply-Combine\nindex: 1\nknitr:\n  opts_chunk:\n    collapse: true\nexecute:\n  echo: true\n---\n\n\n# Prepro 3: Demo\n\nIn this demo, we will introduce other tools from the Tidyverse and explain them using examples. The tidyverse tools make dealing with data much easier and have now become a must have when dealing with data in R.\n\nWe cannot show you all the possibilities of tidyverse. Therefore, we will focus on the most important components and also introduce additional functionalities that we often use but may not yet be known to you. If you want to delve deeper into the topic, you should read @wickham2017. An extensive, although not comprehensive version is available online^[ http://r4ds.had.co.nz/], and the full eBook can be obtained from the library ^[ https://ebookcentral.proquest.com/lib/zhaw/detail.action?docID=4770093].\n\nWe will need the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"dplyr\")\nlibrary(\"tidyr\")\nlibrary(\"lubridate\")\nlibrary(\"readr\")\nlibrary(\"ggplot2\")\n```\n:::\n\n\n## Split Apply Combine\n\n### Load data\n\nLets load the weather data (source MeteoSchweiz) from the last exercise.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather <- read_delim(\"datasets/prepro/weather.csv\", \",\")\n\nweather <- weather |>\n  mutate(\n    stn = as.factor(stn),\n    time = as.POSIXct(as.character(time), format = \"%Y%m%d%H\")\n  )\n```\n:::\n\n\n### Calculate values\n\nWe would like to calculate the average of all measured temperature values. To do this, we could use the following command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(weather$tre200h0, na.rm = TRUE)\n## [1] 6.324744\n```\n:::\n\n\nThe option `na.rm = T` means that NA values should be excluded from the calculation.\n\nVarious values can be calculated using the same approach (e.g. the maximum (`max()`), minimum (`min()`), median (`median()`) and much more).\n\nThis approach only works well if we want to calculate values across *all* observations for a variable (column). As soon as we want to group the observations, it becomes difficult. For example, if we want to calculate the average temperature *per month*.\n\n### Convenience Variables\n\nTo solve this task, the month must first be extracted (the month is the *convenience variable*). For this we need the `lubridate::month()` function.\n\nNow the month **convenience variable** can be created. Without using `dpylr`, a new column can be added as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather$month <- month(weather$time)\n```\n:::\n\n\nWith `dplyr` (see ^[ @wickham2017, Chapter 10 /http://r4ds.had.co.nz/transform.html]), the same command looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather <- mutate(weather, month = month(time))\n```\n:::\n\n\nThe main advantage of `dplyr` is not yet apparent at this point. However, this will become clear later.\n\n### Calculate values from groups\n\nTo calculate the average value per month with base R, you can first create a subset with `[]` and calculate the average value as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(weather$tre200h0[weather$month == 1], na.rm = TRUE)\n## [1] -1.963239\n```\n:::\n\n\nWe have to repeat this every month, which of course is very cumbersome. That is why we use the `dplyr` package. This, allows us to complete the task (calculate temperature means per month) as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(group_by(weather, month), temp_average = mean(tre200h0, na.rm = TRUE))\n## # A tibble: 13 × 2\n##    month temp_average\n##    <dbl>        <dbl>\n##  1     1       -1.96 \n##  2     2        0.355\n##  3     3        2.97 \n##  4     4        4.20 \n##  5     5       11.0  \n##  6     6       12.4  \n##  7     7       13.0  \n##  8     8       15.0  \n##  9     9        9.49 \n## 10    10        8.79 \n## 11    11        1.21 \n## 12    12       -0.898\n## 13    NA        2.95\n```\n:::\n\n\n### Concatenate vs. Nest\n\nTranslated into English, the above operation is as follows:\n\n1) Take the `weather` dataset\n2) Form groups per year  (`group_by(weather, year)`)\n3) Calculate the mean temperature (`mean(tre200h0)`)\n\nThe translation from `R` -> English looks different because we read the operation in a *concatenated form* in English (operation 1->2->3) while the computer reads it as a *nested* operation 3(2(1)). To make `R` closer to English, you can use the `|>` operator (see ^[ @wickham2017, Chapter 14 / http://r4ds.had.co.nz/pipes.html]).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1 take the dataset \"weather\"\n# 2 form groups per month\n# 3 calculate the average temperature\n\nsummarise(group_by(weather, month), temp_average = mean(tre200h0))\n#                  \\__1__/\n#         \\___________2__________/\n# \\___________________3________________________________________/\n\n# becomes:\n\nweather |>                                 # 1\n  group_by(month) |>                       # 2\n  summarise(temp_average = mean(tre200h0)) # 3\n```\n:::\n\n\nThis concatenation by means of `|>` (called pipe) makes the code a lot easier to write and read, and we will use it in the following exercises. Pipe is provided as part of the `magrittr` package and installed with `dplyr`.\n\nThere are several online tutorials about `dplyr` (see^[@wickham2017, Chapter 10 / http://r4ds.had.co.nz/transform.html, or [Hands-on dplyr tutorial..](https://youtu.be/jWjqLW-u3hc)]). Therefore, we will not explain all of these tools in full detail. Instead we will just focus on the important differences for two main functions in `dpylr`: `mutate()` and `summarise()`.\n\n- `summarise()` summarises a data set. The number of observations (rows) is reduced to the number of groups (e.g., one summarised observation (row) per year). In addition, the number of variables (columns) is reduced to those specified in the \"summarise\" function (e.g., `temp_mean`).\n- `mutate` adds *additional* variables (columns) to a `data.frame` (see example below).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Maximum and minimum temperature per calendar week\nweather_summary <- weather |>               # 1) take the dataset \"weather\"\n  filter(month == 1) |>                     # 2) filter for the month of January\n  mutate(day = day(time)) |>                # 3) create a new column \"day\"\n  group_by(day) |>                          # 4) Use the new column to form groups\n  summarise(\n    temp_max = max(tre200h0, na.rm = TRUE), # 5) Calculate the maximum\n    temp_min = min(tre200h0, na.rm = TRUE)  # 6) Calculate the minimum\n  )\n\nweather_summary\n## # A tibble: 31 × 3\n##      day temp_max temp_min\n##    <int>    <dbl>    <dbl>\n##  1     1      5.8     -4.4\n##  2     2      2.8     -4.3\n##  3     3      4.2     -3.1\n##  4     4      4.7     -2.8\n##  5     5     11.4     -0.6\n##  6     6      6.7     -1.6\n##  7     7      2.9     -2.8\n##  8     8      0.2     -3.6\n##  9     9      2.1     -8.8\n## 10    10      1.6     -2.4\n## # ℹ 21 more rows\n```\n:::\n\n\n## Reshaping data\n\n### Wide → long\n\nTables can be transformed from *wide* to* long* using `tidyr` (see ^[ https://r4ds.had.co.nz/tidy-data.html#pivoting]). This package also works perfectly with piping (`|>`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary |>\n  pivot_longer(c(temp_max, temp_min))\n## # A tibble: 62 × 3\n##      day name     value\n##    <int> <chr>    <dbl>\n##  1     1 temp_max   5.8\n##  2     1 temp_min  -4.4\n##  3     2 temp_max   2.8\n##  4     2 temp_min  -4.3\n##  5     3 temp_max   4.2\n##  6     3 temp_min  -3.1\n##  7     4 temp_max   4.7\n##  8     4 temp_min  -2.8\n##  9     5 temp_max  11.4\n## 10     5 temp_min  -0.6\n## # ℹ 52 more rows\n```\n:::\n\n\nIn the `pivot_longer()` command, we have to define which columns should be summarised (in this case: `temp_max`, `temp_min`, `temp_mean`). Alternatively, we can specify which columns we do *not* want to summarise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary |>\n  pivot_longer(-day)\n## # A tibble: 62 × 3\n##      day name     value\n##    <int> <chr>    <dbl>\n##  1     1 temp_max   5.8\n##  2     1 temp_min  -4.4\n##  3     2 temp_max   2.8\n##  4     2 temp_min  -4.3\n##  5     3 temp_max   4.2\n##  6     3 temp_min  -3.1\n##  7     4 temp_max   4.7\n##  8     4 temp_min  -2.8\n##  9     5 temp_max  11.4\n## 10     5 temp_min  -0.6\n## # ℹ 52 more rows\n```\n:::\n\n\nIf we want to set the names of new columns (instead of `name` and `value`), this can be achieved by using `names_to` or `values_to`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary_long <- weather_summary |>\n  pivot_longer(-day, names_to = \"MeasurementType\", values_to = \"MeasurementValue\")\n```\n:::\n\n\nThe first 6 lines of `weather_summary_long`:\n\n\n::: {.cell}\n::: {.cell-output-display}\n| day|MeasurementType | MeasurementValue|\n|---:|:---------------|----------------:|\n|   1|temp_max        |              5.8|\n|   1|temp_min        |             -4.4|\n|   2|temp_max        |              2.8|\n|   2|temp_min        |             -4.3|\n|   3|temp_max        |              4.2|\n|   3|temp_min        |             -3.1|\n:::\n:::\n\n\nThe first 6 lines of `weather_sry`:\n\n\n::: {.cell}\n::: {.cell-output-display}\n| day| temp_max| temp_min|\n|---:|--------:|--------:|\n|   1|      5.8|     -4.4|\n|   2|      2.8|     -4.3|\n|   3|      4.2|     -3.1|\n|   4|      4.7|     -2.8|\n|   5|     11.4|     -0.6|\n|   6|      6.7|     -1.6|\n:::\n:::\n\n\nNote: `weather_summary_long` comprises 62 observations (rows), which is twice as much as `weather_summary`, because we have combined two of the columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(weather_summary)\n## [1] 31\nnrow(weather_summary_long)\n## [1] 62\n```\n:::\n\n\nLong tables are more practical in many situations. For example, visualising using `ggplot2` (you will learn about this package in the \"InfoVis\" block) is much easier with *long tables*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(weather_summary_long, aes(day, MeasurementValue, colour = MeasurementType)) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](Prepro3_Demo_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n### Long → wide\n\nThe counterpart to `pivot_longer` is `pivot_wider`. This function allows us to convert a *long* table into a *wide* one. To do this, we must specify in `names_from` which column the new column names should be created from (`names_from`) and  which column the values should originate from (`values_from`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary_long |>\n  pivot_wider(names_from = MeasurementType, values_from = MeasurementValue)\n## # A tibble: 31 × 3\n##      day temp_max temp_min\n##    <int>    <dbl>    <dbl>\n##  1     1      5.8     -4.4\n##  2     2      2.8     -4.3\n##  3     3      4.2     -3.1\n##  4     4      4.7     -2.8\n##  5     5     11.4     -0.6\n##  6     6      6.7     -1.6\n##  7     7      2.9     -2.8\n##  8     8      0.2     -3.6\n##  9     9      2.1     -8.8\n## 10    10      1.6     -2.4\n## # ℹ 21 more rows\n```\n:::\n\n\nFor comparison: We have to plot each column individually in `ggplot2` for a *wide* table. While this is not a problem when we are only working with a few variables, like here, with a high number this quickly becomes tedious.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(weather_summary) +\n  geom_line(aes(day, temp_max)) +\n  geom_line(aes(day, temp_min))\n```\n\n::: {.cell-output-display}\n![](Prepro3_Demo_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Prepro3_Demo_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}