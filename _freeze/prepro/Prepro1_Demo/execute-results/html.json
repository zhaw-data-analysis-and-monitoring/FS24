{
  "hash": "7491289f3948ea37a852fe8e73078dd8",
  "result": {
    "markdown": "---\ndate: 2023-10-10\nlesson: PrePro1\nthema: Datentypen\nindex: 1\nknitr:\n  opts_chunk: \n    collapse: true\n---\n\n\n# Prepro 1: Demo\n\nDiese Demo kann auch als [R Script heruntergeladen werden](Prepro1_Demo.R) (Rechtsklick → *Save Target As..*)\n\n### Datentypen\n\n#### Numerics\n\nUnter die Kategorie `numeric` fallen in R zwei Datentypen:\n\n-   `double`: Gleitkommazahl (z.B. 10.3, 7.3)\n-   `integer`: Ganzzahl (z.B. 10, 7)\n\n##### Doubles\n\nFolgendermassen wird eine Gleitkommazahl einer Variabel zuweisen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10.3\n\nx\n## [1] 10.3\n\ntypeof(x)\n## [1] \"double\"\n```\n:::\n\n\nStatt `<-` kann auch `=` verwendet werden. Dies funktioniert aber nicht in allen Situationen, und ist zudem leicht mit `==` zu verwechseln.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = 7.3\ny\n## [1] 7.3\n```\n:::\n\n\nOhne explizite Zuweisung nimmt R immer den Datentyp `double`an:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- 42\ntypeof(z)\n## [1] \"double\"\nis.integer(z)\n## [1] FALSE\nis.numeric(z)\n## [1] TRUE\nis.double(z)\n## [1] TRUE\n```\n:::\n\n\n#### Ganzzahl / Integer\n\nErst wenn man eine Zahl explizit als `integer` definiert (mit `as.integer()` oder `L`), wird sie auch als solches abgespeichert.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- as.integer(z)\nis.numeric(a)\n## [1] TRUE\nis.integer(a)\n## [1] TRUE\n\nc <- 8L\nis.numeric(c)\n## [1] TRUE\nis.integer(c)\n## [1] TRUE\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(a)\n## [1] \"integer\"\n\nis.numeric(a)\n## [1] TRUE\nis.integer(a)\n## [1] TRUE\n```\n:::\n\n\n\n\n#### Logische Abfragen\n\nWird auch auch als boolesch (Eng. **boolean**) bezeichnet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- 3\nf <- 6\n\ne > f\n## [1] FALSE\n\n\nsonnig <- TRUE\ntrocken <- FALSE\n\nsonnig & !trocken\n## [1] TRUE\n```\n:::\n\n\n\n\n#### Zeichenketten\n\nZeichenketten (Eng. **character**) stellen Text dar\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- as.character(3.14)\ns\n## [1] \"3.14\"\ntypeof(s)\n## [1] \"character\"\n```\n:::\n\n\nZeichenketten verbinden / zusammenfügen (Eng. **concatenate**)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfname <- \"Andrea\"\nlname <- \"Muster\"\npaste(fname, lname)\n## [1] \"Andrea Muster\"\n\nfname2 <- \"Simon\"\nfname == fname2\n## [1] FALSE\n```\n:::\n\n\n#### Factors\n\nMit Factors wird in R eine Sammlung von Zeichenketten bezeichnet, die sich wiederholen, z.B. Wochentage (es gibt nur 7 unterschiedliche Werte für \"Wochentage\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwochentage <- c(\"Donnerstag\", \"Freitag\", \"Samstag\")\n\ntypeof(wochentage)\n## [1] \"character\"\n\nwochentage_fac <- as.factor(wochentage)\n\nwochentage\n## [1] \"Donnerstag\" \"Freitag\"    \"Samstag\"\nwochentage_fac\n## [1] Donnerstag Freitag    Samstag   \n## Levels: Donnerstag Freitag Samstag\n```\n:::\n\n\nWie man oben sieht, unterscheiden sich `character vectors` und `factors` v.a. dadurch, dass letztere über sogenannte `levels` verfügt. Diese `levels` entsprechen den eindeutigen Werten.\n\nZudem ist fällt auf, dass die Reihenfolge der Wohentag alphabetisch sortiert ist. Eine Ordnung kann man mit dem Befehl `ordered = T` festlegen, dabei muss die Reihenfolge der Werte im Argument `levels =` explizit festgehalten werden[^ordered].\n\n[^ordered]: `ordered = T` kann nur bei der Funktion `factor()` spezifiziert werden, nicht bei `as.factor()`. Ansonsten sind `factor()` und `as.factor()` sehr ähnlich.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(wochentage, levels = c(\"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\", \"Sonntag\"), ordered = TRUE)\n## [1] Donnerstag Freitag    Samstag   \n## 7 Levels: Montag < Dienstag < Mittwoch < Donnerstag < Freitag < ... < Sonntag\n```\n:::\n\n\nBeachtet das `<`-Zeichen zwischen den Levels!\n\n\n#### Zeit/Datum\n\nUm in R mit Datum/Zeit Datentypen umzugehen, müssen sie als `POSIXct` eingelesen werden. Anders als Beispielsweise bei Excel, sollten in R Datum und Uhrzeit immer **zusammen** gespeichert werden (in *einem* Objekt oder *einem* Vektor).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatum <- \"2017-10-01 13:45:10\"\n\n# konvertiert character in POSIXct:\nas.POSIXct(datum)\n## [1] \"2017-10-01 13:45:10 CEST\"\n```\n:::\n\n\nWenn das die Zeichenkette in dem obigen Format (`Jahr-Monat-Tag Stunde:Minute:Sekunde`) daher kommt, braucht `as.POSIXct`keine weiteren Informationen. \n\nSollte das Format von dem aber Abweichen, muss man der Funktion das genaue Schema jedoch mitteilen. Der Syntax dafür kann via `?strptime` nachgeschlagen werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatum <- \"01.10.2017 13:45\"\n\n# konvertiert character in POSIXct:\nas.POSIXct(datum, format = \"%d.%m.%Y %H:%M\")\n## [1] \"2017-10-01 13:45:00 CEST\"\n\ndatum2 <- as.POSIXct(datum, format = \"%d.%m.%Y %H:%M\")\n```\n:::\n\n\nBeachtet, dass in den den obigen Beispiel R automatisch eine Zeitzone angenommen hat (`CEST`). R geht davon aus, dass die Zeitzone der **System Timezone** (`Sys.timezone()`) entspricht.\n\nUm nun aus dem Datum wieder Spezifische bestandteile zu extrahieren, kann man theoretisch die gleichen Codes nochmal verwenden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrftime(datum2, format = \"%m\") # extrahiert den Monat als Zahl\n## [1] \"10\"\nstrftime(datum2, format = \"%b\") # extrahiert den Monat mit Namen (abgekürzt)\n## [1] \"Okt\"\nstrftime(datum2, format = \"%B\") # extrahiert den Monat mit Namen (ausgeschrieben)\n## [1] \"Oktober\"\n```\n:::\n\n\nEinfacher sind an dieser Stelle aber die Functions aus lubridate:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"lubridate\")\n\nmonth(datum2) # extrahiert den Monat als Zahl\n## [1] 10\nmonth(datum2, label = TRUE, abbr = TRUE) # extrahiert den Monat mit Namen (abgekürzt)\n## [1] Okt\n## 12 Levels: Jan < Feb < Mär < Apr < Mai < Jun < Jul < Aug < Sep < ... < Dez\nmonth(datum2, label = TRUE, abbr = FALSE) # extrahiert den Monat mit Namen (ausgeschrieben)\n## [1] Oktober\n## 12 Levels: Januar < Februar < März < April < Mai < Juni < Juli < ... < Dezember\n```\n:::\n\n\n\n### Vectors\n\nMit `c()` können eine Reihe von Werten vom gleichen Datentyp einer Variabel zugewiesen werden (als `vector`). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(10, 20, 33, 42, 54, 66, 77)\nvec\n## [1] 10 20 33 42 54 66 77\nvec[5]\n## [1] 54\nvec[2:4]\n## [1] 20 33 42\n\nvec2 <- vec[2:4]\n```\n:::\n\n\n### Lists\n\nEine `list` ist eine Sammlung von Objekten, die nicht unbedingt vom gleichen Datentyp sein müssen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nmylist <- list(\"q\", TRUE, 3.14)\n```\n:::\n\n\nDie einzelnen Elemente einer Liste können auch Namen zugewiesen werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nmylist2 <- list(fav_letter = \"q\", fav_boolean = TRUE, fav_number = 3.14)\n\nmylist2\n## $fav_letter\n## [1] \"q\"\n## \n## $fav_boolean\n## [1] TRUE\n## \n## $fav_number\n## [1] 3.14\n```\n:::\n\n\n\n### Data Frames und Conveniance Variabeln\n\nWenn jeder Eintrag einer Liste gleich lang ist, kann diese Liste auch als Tabelle verstanden werden. Idealerweise sind die Elemente benannt, welche dann als Spaltennamen verwendet werden können.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(mylist2)\n##   fav_letter fav_boolean fav_number\n## 1          q        TRUE       3.14\n```\n:::\n\n\nMit der Funktion `data.frame` kann direkt eine Tabelle erstellt werden, ohne zuerst eine Liste zu erstellen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  Stadt = c(\"Zürich\", \"Genf\", \"Basel\", \"Bern\", \"Lausanne\"),\n  Ankunft = c(\n    \"1.1.2017 10:00\", \"1.1.2017 14:00\",\n    \"1.1.2017 13:00\", \"1.1.2017 18:00\", \"1.1.2017 21:00\"\n  )\n)\n\nstr(df)\n## 'data.frame':\t5 obs. of  2 variables:\n##  $ Stadt  : chr  \"Zürich\" \"Genf\" \"Basel\" \"Bern\" ...\n##  $ Ankunft: chr  \"1.1.2017 10:00\" \"1.1.2017 14:00\" \"1.1.2017 13:00\" \"1.1.2017 18:00\" ...\n```\n:::\n\n\nUm Daten Abzufragen, nutzt man das `$` Symbol:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Stadt\n## [1] \"Zürich\"   \"Genf\"     \"Basel\"    \"Bern\"     \"Lausanne\"\n```\n:::\n\n\nSo können auch neue Spalten hinzugefügt oder bestehende verändert werden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Einwohner <- c(400000, 200000, 175000, 14000, 130000)\n\ndf$Einwohner <- as.integer(df$Einwohner)\n```\n:::\n\n\nIn der obigen `data.frame` wurde die Spalte `Einwohner` als Fliesskommazahl abgespeichert. Dies ist zwar nicht tragisch, aber da wir wissen das es sich hier sicher um Ganzzahlen handelt, können wir das korrigieren. Wichtiger ist aber, dass wir die Ankunftszeit (Spalte`Ankunft`) von einem `Factor` in ein Zeitformat (`POSIXct`) umwandeln.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\ndf$Ankunft <- as.POSIXct(df$Ankunft, format = \"%d.%m.%Y %H:%M\")\n\ndf$Ankunft\n## [1] \"2017-01-01 10:00:00 CET\" \"2017-01-01 14:00:00 CET\"\n## [3] \"2017-01-01 13:00:00 CET\" \"2017-01-01 18:00:00 CET\"\n## [5] \"2017-01-01 21:00:00 CET\"\n```\n:::\n\n\n\nDiese Spalten können nun helfen, um Hilfsvariablen (**convenience variables**) zu erstellen. Z.B. kann die Ankunftszeit von der Spalte `Ankunft`abgeleitet werden. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Ankunft_stunde <- hour(df$Ankunft)\n\ndf$Ankunft_stunde\n## [1] 10 14 13 18 21\n```\n:::\n\n\n\nOder aber, wir teilen die Städte in gross, mittel und klein ein.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Groesse <- \"keine Angabe\"\n\ndf$Groesse[df$Einwohner > 300000] <- \"gross\"\ndf$Groesse[df$Einwohner <= 300000 & df$Einwohner > 150000] <- \"mittel\"\ndf$Groesse[df$Einwohner <= 150000] <- \"klein\"\n\ndf$Groesse\n## [1] \"gross\"  \"mittel\" \"mittel\" \"klein\"  \"klein\"\n```\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}