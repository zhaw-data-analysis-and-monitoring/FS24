{
  "hash": "79cde5e47509138d50e306a8159ad044",
  "result": {
    "markdown": "---\ndate: 2023-10-10\nlesson: PrePro1\nthema: Data Types\nindex: 1\nknitr:\n  opts_chunk:\n    collapse: true\n---\n\n\n# Prepro 1: Demo\n\nThis demo's source code can also [be downloaded as an R Script](Prepro1_Demo.R) (right click → *Save Target As..*)\n\n### Data types\n\n#### Numerics\n\nThere are two different `numeric` data types in R:\n\n- `double`: floating-point number (e.g. 10.3, 7.3)\n- `integer` (e.g. 10, 7)\n\n##### Doubles\n\nA floating point number is assigned to a variable as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10.3\n\nx\n## [1] 10.3\n\ntypeof(x)\n## [1] \"double\"\n```\n:::\n\n\nEither `<-` or `=` can be used. However, the latter does not work in all situations, and is also easily confused with `==`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = 7.3\ny\n## [1] 7.3\n```\n:::\n\n\nIf the numeric data type is not explicitly assigned, R always uses `double`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- 42\ntypeof(z)\n## [1] \"double\"\nis.integer(z)\n## [1] FALSE\nis.numeric(z)\n## [1] TRUE\nis.double(z)\n## [1] TRUE\n```\n:::\n\n\n#### Integer\n\nA number is only stored as an `integer` if it is explicitly defined as one (using `as.integer()` or `L`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- as.integer(z)\nis.numeric(a)\n## [1] TRUE\nis.integer(a)\n## [1] TRUE\n\nc <- 8L\nis.numeric(c)\n## [1] TRUE\nis.integer(c)\n## [1] TRUE\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(a)\n## [1] \"integer\"\n\nis.numeric(a)\n## [1] TRUE\nis.integer(a)\n## [1] TRUE\n```\n:::\n\n\n#### Logical queries\n\nAlso known as a **Boolean**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- 3\nf <- 6\n\ne > f\n## [1] FALSE\n\n\nsunny <- TRUE\ndry <- FALSE\n\nsunny & !dry\n## [1] TRUE\n```\n:::\n\n\n#### Character\n\n**Character** strings contain text.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- as.character(3.14)\ns\n## [1] \"3.14\"\ntypeof(s)\n## [1] \"character\"\n```\n:::\n\n\nConnecting / concatenating character strings\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfname <- \"Andrea\"\nlname <- \"Muster\"\npaste(fname, lname)\n## [1] \"Andrea Muster\"\n\nfname2 <- \"Simon\"\nfname == fname2\n## [1] FALSE\n```\n:::\n\n\n#### Factors\n\nFactors in R denote a collection of repeating character strings, e.g. weekdays (there are only 7 different values for \"weekdays\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweekdays <- c(\"Thursday\", \"Friday\", \"Saturday\")\n\ntypeof(weekdays)\n## [1] \"character\"\n\nweekdays_fac <- as.factor(weekdays)\n\nweekdays\n## [1] \"Thursday\" \"Friday\"   \"Saturday\"\nweekdays_fac\n## [1] Thursday Friday   Saturday\n## Levels: Friday Saturday Thursday\n```\n:::\n\n\nAs shown in the above example, the main difference between `character vectors` and character `factors` is that factors also have `levels`. These `levels` correspond to the unique values.\n\nBy default, the order of the days is alphabetical. However, a specific order can be set using `ordered = T`, with the desired order defined in `levels =` [^ordered].\n\n[^ordered]: `ordered = T` can only be specified for the `factor()` function, not for `as.factor()`. Otherwise, `factor()` and `as.factor()` are very similar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(weekdays, levels = c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"), ordered = TRUE)\n## [1] Thursday Friday   Saturday\n## 7 Levels: Monday < Tuesday < Wednesday < Thursday < Friday < ... < Sunday\n```\n:::\n\n\nNote that there is a `<` sign between the levels!\n\n#### Time/Date\n\nR requires time/date data types to be read in `POSIXct` format. It should be noted that date and time are always stored **together** in R (in *one object* or *one* vector), unlike in other programs, such as Excel, where these items can be stored separately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndate <- \"2017-10-01 13:45:10\"\n\n# converts character to POSIXct:\nas.POSIXct(date)\n## [1] \"2017-10-01 13:45:10 CEST\"\n```\n:::\n\n\nIf the character string is delivered in the above format (`year-month-day hour:minute:second`), `as.POSIXct` needs no further information.\n\nHowever, if the format is different, the function must be provided with the exact format. The  syntax for the function can be found in`?strptime`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndate <- \"01.10.2017 13:45\"\n\n# converts character to POSIXct:\nas.POSIXct(date, format = \"%d.%m.%Y %H:%M\")\n## [1] \"2017-10-01 13:45:00 CEST\"\n\ndate2 <- as.POSIXct(date, format = \"%d.%m.%Y %H:%M\")\n```\n:::\n\n\nYou can see in the above example that R has automatically set the time zone (`CEST`) to the **system time zone** (`Sys.timezone ()`).\n\nTheoretically, the same code can also be used to extract specific components from a date.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrftime(date2, format = \"%m\") # extracts the month as a number\n## [1] \"10\"\nstrftime(date2, format = \"%b\") # extracts the month by name (abbreviated)\n## [1] \"Okt\"\nstrftime(date2, format = \"%B\") # extracts the month by name (full)\n## [1] \"Oktober\"\n```\n:::\n\n\nHowever, the functions from lubridate are simpler to use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"lubridate\")\n\nmonth(date2) # extracts the month as a number\n## [1] 10\nmonth(date2, label = TRUE, abbr = TRUE) # extracts the month by name (abbreviated)\n## [1] Okt\n## 12 Levels: Jan < Feb < Mär < Apr < Mai < Jun < Jul < Aug < Sep < ... < Dez\nmonth(date2, label = TRUE, abbr = FALSE) # extracts the month by name (full)\n## [1] Oktober\n## 12 Levels: Januar < Februar < März < April < Mai < Juni < Juli < ... < Dezember\n```\n:::\n\n\n### Vectors\n\nUsing `c()`, a set of values of the same data type can be assigned to a variable (as a `vector`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(10, 20, 33, 42, 54, 66, 77)\nvec\n## [1] 10 20 33 42 54 66 77\nvec[5]\n## [1] 54\nvec[2:4]\n## [1] 20 33 42\n\nvec2 <- vec[2:4]\n```\n:::\n\n\n### Lists\n\nA `list` is a collection of objects that do not need to be the same data type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- list(\"q\", TRUE, 3.14)\n```\n:::\n\n\nThe individual elements in a list can also be assigned names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist2 <- list(fav_letter = \"q\", fav_boolean = TRUE, fav_number = 3.14)\n\nmylist2\n## $fav_letter\n## [1] \"q\"\n## \n## $fav_boolean\n## [1] TRUE\n## \n## $fav_number\n## [1] 3.14\n```\n:::\n\n\n### Data frames and convenience variables\n\nIf each entry in a list is the same length, this list can also be represented as a table or frame. Ideally, the names of the columns in the frame should also be defined.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(mylist2)\n##   fav_letter fav_boolean fav_number\n## 1          q        TRUE       3.14\n```\n:::\n\n\nThe `data.frame` function allows a table to be created without first having to create a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  City = c(\"Zurich\", \"Geneva\", \"Basel\", \"Bern\", \"Lausanne\"),\n  Arrival = c(\n    \"1.1.2017 10:00\", \"1.1.2017 14:00\",\n    \"1.1.2017 13:00\", \"1.1.2017 18:00\", \"1.1.2017 21:00\"\n  )\n)\n\nstr(df)\n## 'data.frame':\t5 obs. of  2 variables:\n##  $ City   : chr  \"Zurich\" \"Geneva\" \"Basel\" \"Bern\" ...\n##  $ Arrival: chr  \"1.1.2017 10:00\" \"1.1.2017 14:00\" \"1.1.2017 13:00\" \"1.1.2017 18:00\" ...\n```\n:::\n\n\nThe `$` symbol can be used to query data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$City\n## [1] \"Zurich\"   \"Geneva\"   \"Basel\"    \"Bern\"     \"Lausanne\"\n```\n:::\n\n\nNew columns can be added and existing ones can be changed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Residents <- c(400000, 200000, 175000, 14000, 130000)\n\ndf$Residents <- as.integer(df$Residents)\n```\n:::\n\n\nIn the `data.frame` above, the `Residents` column has been saved as a floating-point number. While this is not a problem, since we know that these are integers, we can change the data type. It is more important, however, that we convert the `Arrival` time (Arrivalcolumn) from a `factor` to a time format (`POSIXct`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Arrival <- as.POSIXct(df$Arrival, format = \"%d.%m.%Y %H:%M\")\n\ndf$Arrival\n## [1] \"2017-01-01 10:00:00 CET\" \"2017-01-01 14:00:00 CET\"\n## [3] \"2017-01-01 13:00:00 CET\" \"2017-01-01 18:00:00 CET\"\n## [5] \"2017-01-01 21:00:00 CET\"\n```\n:::\n\n\nThese columns can now help to create **convenience variables**. E.g., the arrival time can be derived from the `Arrival` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Arrival_hour <- hour(df$Arrival)\n\ndf$Arrival_hour\n## [1] 10 14 13 18 21\n```\n:::\n\n\nWe can also divide the cities into large, medium and small.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Size <- \"no information\"\n\ndf$Size[df$Residents > 300000] <- \"large\"\ndf$Size[df$Residents <= 300000 & df$Residents > 150000] <- \"medium\"\ndf$Size[df$Residents <= 150000] <- \"small\"\n\ndf$Size\n## [1] \"large\"  \"medium\" \"medium\" \"small\"  \"small\"\n```\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}