{
  "hash": "8fee5ff30317eeb8fc96448e0df489ac",
  "result": {
    "markdown": "---\ndate: 2023-10-16\nlesson: PrePro2\nthema: Piping / Joins\nindex: 3\nexecute: \n  echo: true   # set to true to show musterlösung\n  output: true # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true\n---\n\n\n# Prepro 2: Übung B\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Benötigte Packages\nlibrary(\"dplyr\")\nlibrary(\"readr\")\n```\n:::\n\n\n## Aufgabe 1\n\nGegeben sind die Daten von drei Sensoren (*sensor1.csv*, *sensor2.csv*, *sensor3.csv*). Lese die Datensätze ein.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsensor1 <- read_delim(\"datasets/prepro/sensor1.csv\", \";\")\nsensor2 <- read_delim(\"datasets/prepro/sensor2.csv\", \";\")\nsensor3 <- read_delim(\"datasets/prepro/sensor3.csv\", \";\")\n```\n:::\n\n\n## Aufgabe 2\n\nErstelle aus den 3 Dataframes eine einzige Dataframe, die aussieht wie unten dargestellt. Nutze dafür zwei joins aus `dplyr` um 3 `data.frames` miteinander zu verbinden. Bereinige im Anschluss die Spaltennamen ([wie geht das?](https://www.statology.org/how-to-rename-data-frame-columns-in-r/)).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsensor1_2 <- full_join(sensor1, sensor2, \"Datetime\")\n\nsensor1_2 <- rename(sensor1_2, sensor1 = Temp.x, sensor2 = Temp.y)\n\nsensor_all <- full_join(sensor1_2, sensor3, by = \"Datetime\")\n\nsensor_all <- rename(sensor_all, sensor3 = Temp)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n|Datetime      | sensor1| sensor2| sensor3|\n|:-------------|-------:|-------:|-------:|\n|16102017_1800 |    23.5|    13.5|    26.5|\n|17102017_1800 |    25.4|    24.4|    24.4|\n|18102017_1800 |    12.4|    22.4|    13.4|\n|19102017_1800 |     5.4|    12.4|     7.4|\n|23102017_1800 |    23.5|    13.5|      NA|\n|24102017_1800 |    21.3|    11.3|      NA|\n:::\n:::\n\n\n## Aufgabe 3\n\nImportiere die Datei *sensor_fail.csv* in `R`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsensor_fail <- read_delim(\"datasets/prepro/sensor_fail.csv\", delim = \";\")\n```\n:::\n\n\n`sensor_fail.csv` hat eine Variabel `SensorStatus`: `1` bedeutet der Sensor misst, `0` bedeutet der Sensor misst nicht. Fälschlicherweise wurde auch dann der Messwert `Temp = 0` erfasst, wenn `Sensorstatus = 0`. Richtig wäre hier `NA` (not available). Korrigiere den Datensatz entsprechend.\n\n\n::: {.cell}\n::: {.cell-output-display}\n|Sensor | Temp| Hum_%|Datetime      | SensorStatus|\n|:------|----:|-----:|:-------------|------------:|\n|Sen102 |  0.6|    98|16102017_1800 |            1|\n|Sen102 |  0.3|    96|17102017_1800 |            1|\n|Sen102 |  0.0|    87|18102017_1800 |            1|\n|Sen102 |  0.0|    86|19102017_1800 |            0|\n|Sen102 |  0.0|    98|23102017_1800 |            0|\n|Sen102 |  0.0|    98|24102017_1800 |            0|\n|Sen102 |  0.0|    96|25102017_1800 |            1|\n|Sen103 | -0.3|    87|26102017_1800 |            1|\n|Sen103 | -0.7|    98|27102017_1800 |            1|\n|Sen103 | -1.2|    98|28102017_1800 |            1|\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# mit base-R:\nsensor_fail$Temp_correct[sensor_fail$SensorStatus == 0] <- NA\nsensor_fail$Temp_correct[sensor_fail$SensorStatus != 0] <- sensor_fail$Temp #Warnmeldung kann ignoriert werden.\n\n# das gleiche mit dplyr:\nsensor_fail <- sensor_fail |>\n  mutate(Temp_correct = ifelse(SensorStatus == 0, NA, Temp))\n```\n:::\n\n\n## Aufgabe 4\n\nWarum spielt das es eine Rolle, ob `0` oder `NA` erfasst wird? Berechne die Mittlere der Temperatur / Feuchtigkeit nach der Korrektur. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mittelwerte der falschen Sensordaten: 0 fliesst in die Berechnung\n# ein und verfälscht den Mittelwert\nmean(sensor_fail$Temp)\n## [1] -0.13\n\n# Mittelwerte der korrigierten Sensordaten: mit na.rm = TRUE werden\n# NA-Werte aus der Berechnung entfernt.\nmean(sensor_fail$Temp_correct, na.rm = TRUE)\n## [1] -0.1857143\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}